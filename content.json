[{"title":"vim_command_sed","date":"2015-02-03T12:33:00.000Z","path":"2015/02/03/vim命令-sed/","text":"简介sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上。 sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。 定址定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。 以下例子一下面的文件内容测试 test.vim hello word ！ this is a test ? asdfghjkl qwertyuiop zxcvbnm come on he he he he ha ha ha ha 地址是一个数字，则表示行号，是“$”符号，则表示最后一行。 1234sed -n &apos;4p&apos; test.vim终端只打印第四行，即：qwertyuiopsed -n &apos;$p&apos; test.vim终端只打印最后一行，即：ha ha ha ha 只显示指定行范围内的文件内容 12sed -n &apos;3,6p&apos; test.vim只查看文件的第3行到第6行的文件内容 逗号做分隔符，对行范围内的内容的做作 1234567891011121314151617sed &apos;2,3d&apos; test.vim删除第二行到第五行的内容,执行命令后的结果 //hello word ！ qwertyuiop zxcvbnm come on he he he he ha ha ha hased &apos;/zx/,/he/d&apos; test.vim删除包含‘zx’的行到包含‘he’的行，执行命令后的结果 //hello word ！ this is a test ? asdfghjkl qwertyuiop ha ha ha hased &apos;/is/,4d&apos; test.vim删除包含‘is’的行到第四行的内容 命令与选项sed命令告诉sed如何处理由地址指定的各输入行，如果没有指定地址则处理所有的输入行。 1. sed命令 命令 功能 a\\ 在当前行后添加一行或多行。多行时除最后一行外，每行末尾需用“\\”续行 c\\ 用此符号后的新文本替换当前行中的文本。多行时除最后一行外，每行末尾需用”\\”续行 i\\ 在当前行之前插入文本。多行时除最后一行外，每行末尾需用”\\”续行 d 删除行 h 把模式空间里的内容复制到暂存缓冲区 H 把模式空间里的内容追加到暂存缓冲区 g 把暂存缓冲区里的内容复制到模式空间，覆盖原有的内容 G 把暂存缓冲区的内容追加到模式空间里，追加在原有内容的后面 I 列出非打印字符 p 打印行 n 读入下一输入行，并从下一条命令而不是第一条命令开始对其的处理 q 结束或退出sed r 从文件中读取输入行 ! 对所选行以外的所有行应用命令 s 用一个字符串替换另一个 g 在行内进行全局替换 w 将所选的行写入文件 x 交换暂存缓冲区与模式空间的内容 y 将字符替换为另一字符（不能对正则表达式使用y命令） 2. sed选项 选项 功能 -e 进行多项编辑，即对输入行应用多条sed命令时使用 -n 取消默认的输出 -f 指定sed脚本的文件名 退出状态sed不向grep一样，不管是否找到指定的模式，它的退出状态都是0。只有当命令存在语法错误时，sed的退出状态才不是0。 正则表达式元字符与grep一样，sed也支持特殊元字符，来进行模式查找、替换。不同的是，sed使用的正则表达式是括在斜杠线”/“之间的模式。 如果要把正则表达式分隔符”/“改为另一个字符，比如o，只要在这个字符前加一个反斜线，在字符后跟上正则表达式，再跟上这个字符即可。例如：sed -n ‘\\o^Myop’ datafile 元字符 功能 实例 ^ 行首定位符 /^me/ 匹配所有以me开头的行 $ 行尾定位符 /me$/ 匹配所有以me结束的行 . 匹配换行符以外的单个字符 /m..e/ 匹配包含字母m，后跟两个任意字符，再跟字母y的行 * 匹配零个或多个前导字符 /my\\*/ 匹配包含字母m,后跟零个或多个e字母的行 [] 匹配指定字符组内的任一字符 /[Mm]y/ 匹配包含My或my的行 [^] 匹配不在指定字符组内的任一字符 /[^Mm]y/ 匹配包含y，但y之前的那个字符不是M或m的行 \\(..\\) 保存已匹配的字符 1,20s/(you)self/\\1r/ 标记元字符之间的模式，并将其保存为标签1，之后可以使用\\1来引用它。最多可以定义9个标签，从左边开始编号，最左边的是第一个。此例中，对第1到第20行进行处理，you被保存为标签1，如果发现youself，则替换为your。 &amp; 保存查找串以便在替换串中引用 s/my/&amp;/ 符号&amp;代表查找串。my将被替换为(my) \\&lt; 词首定位符 /\\&lt;my/ 匹配包含以my开头的单词的行 \\&gt; 词尾定位符 /my>/ 匹配包含以my结尾的单词的行 x\\{m\\} 连续m个x /9{5}/ 匹配包含连续5个9的行 x\\{m,\\} 至少m个x /9{5,}/ 匹配包含至少连续5个9的行 x{m,n\\} 至少m个，但不超过n个 /9{5,7}/ 匹配包含连续5到7个9的行","tags":[{"name":"VIM_Sed","slug":"VIM-Sed","permalink":"https://github.com/xiao-xi/tags/VIM-Sed/"}]},{"title":"create_certificate","date":"2015-02-01T12:05:19.000Z","path":"2015/02/01/证书相关/","text":"others’ blog 生成certSigningRequest文件该文件是MAC系统生成的，用于在Apple网站上申请推送证书文件。 打开应“钥匙串访问”软件，菜单-&gt;钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书，填写邮箱和名称（随便写）,选择保存到磁盘，此时会生成一个CertificateSigningRequest.certSigningRequest文件。 注册一个支持Push的app id进入developer.apple.com，选择member center-certificates，Identifier &amp; profiles-identifiers-App ids，注册app id，设置app id名称。同时qpp id suffix一栏选择explicit app id，设置bundle id。勾选App Services中得Push Notifications，这样就可以注册一个支持push app id。 生成cer文件该文件用于生成服务端需要的文件。 生成过程：进入developer.apple.com，选择member center-certificates，Identifier &amp; profiles-certificates，然后创建certificate，类型分为Development 和 Product。eg：Development，选择Apple Push Notification service SSL (Sandbox) ，选择之前生成的支持push的Appid，然后提交之前创建的CSR文件,生成cer文件，保存到本地。 生成服务器端的证书文件如果使用网上的mac版PushMeBaby工具，在Mac机器上进行推送使用上面的cer就可以了，如果使用PHP、java/c#开发服务端，需要将cer转换生成pem或p12文件。 在应用服务器采用php的方式将消息推送给APNS， php连接APNS也是需要证书的，打开终端，对上面的证书做如下处理， cd 进入证书所在目录 把.cer文件转换成.pem文件: $ openssl x509 -in aps_developer_identity.cer -inform der -out PushCert.pem 把私钥Push.p12文件转换成.pem文件： $ openssl pkcs12 -nocerts -out PushKey.pem -in Push.p12 Enter Import Password: MAC verified OK Enter PEM pass phrase: Verifying – Enter PEM pass phrase: 你首先需要为.p12文件输入passphrase密码短语，这样OpenSSL可以读它。然后你需要键入一个新的密码短语来加密PEM文件。还是使用”pushchat”来作为PEM的密码短语。你需要选择一些更安全的密码短语。 注意 如果你没有键入一个PEM passphrase，OpenSSL将不会返回一个错误信息，但是产生的.pem文件里面将不会含有私钥。 最后。把私钥和证书整合到一个.pem文件里： $ cat PushCert.pem PushKey.pem &gt; ck.pem 为了测试证书是否工作，执行下面的命令： $ telnet gateway.sandbox.push.apple.com 2195 Trying 17.172.232.226… Connected to gateway.sandbox.push-apple.com.akadns.net. Escape character is ‘^]’. 它将尝试发送一个规则的，不加密的连接到APNS服务。如果你看到上面的反馈，那说明你的MAC能够到达APNS。按下Ctrl+C 关闭连接。如果得到一个错误信息，那么你需要确保你的防火墙允许2195端口。 然后再次连接，这次用我们的SSL证书和私钥来设置一个安全的连接： $ openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert PushChatCert.pem -key PushChatKey.pem Enter pass phrase for PushChatKey.pem: 你会看到一个完整的输出，让你明白OpenSSL在后台做什么。如果连接是成功的，你可以键入一些字符。当你按下回车后，服务就会断开连接。如果在建立连接时有问题，OpenSSL将会给你一个错误消息， ck.pem文件就是我们需要得到php连接APNS 的文件，将ck.pem和push.php放入同一目录上传到服务器。 生成Xcode使用的provisioning文件该文件用于真机调试。 生成过程：进入developer.apple.com，选择member center-certificates，Identifier &amp; profiles-provisioning profiles，然后创建provi file。选择iOS App Development-&gt;AppId-&gt;选中之前生成的支持push的appid-&gt;选中支持的push的certi-&gt;勾选支持的device id-&gt;设置provisioning文件的文件名，即完成provisioning文件的生成。","tags":[{"name":"certificate","slug":"certificate","permalink":"https://github.com/xiao-xi/tags/certificate/"}]},{"title":"Local/Romote_Notification","date":"2015-01-31T05:35:46.000Z","path":"2015/01/31/本地通知和远程推送/","text":"Apple 关于本地通知和远程通知的官方文档 简介远程通知（remote notification）和本地通知（local notification）是两种用户通知类型，远程通知又称为推送通知（push notification）。这两种通知都可以实现当不在前台运行的APP通知使用该APP的用户新信息，这消息可以是消息，临近的日历，或来自远端服务器的新数据等。当操作系统呈现这些通知时，可以显示一个alert提醒或是app icon提醒。在提醒的时候也可以有声音的提示。 当用户点击通知时可以启动APP查看通知详情，也可选择不打开APP忽略通知。 注意 不管是远程通知合适本地通知都与广播通知（NSNotificationCenter）和KVO（key value observe）无关。 本地通知Xcode 6本地通知接收不到出现提示信息： Attempting to schedule a local notification with an alert but haven’t received permission from the user to display alerts with a sound but haven’t received permission from the user to play sounds 原因在于在iOS8系统上需要注册本地通知，这样才能正常使用 iOS8注册本地通知 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { if ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)]) { [application registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeSound | UIUserNotificationTypeBadge | UIUserNotificationTypeAlert categories:nil]]; } return YES; } - (IBAction)registerLocationNotification:(id)sender { UILocalNotification *locationNotification = [[UILocalNotification alloc]init]; NSDate *date = [NSDate dateWithTimeIntervalSinceNow:5]; locationNotification.fireDate = date; locationNotification.timeZone = [NSTimeZone defaultTimeZone]; locationNotification.repeatInterval = NSCalendarUnitSecond; locationNotification.alertBody = @&quot;通知来了。。。&quot;; locationNotification.alertAction = @&quot;通知&quot;; locationNotification.alertLaunchImage = @&quot;3.png&quot;; locationNotification.userInfo = @{@&quot;user&quot;:@&quot;lfx&quot;}; locationNotification.soundName = @&quot;sound.caf&quot;; locationNotification.applicationIconBadgeNumber = 10; [[UIApplication sharedApplication] scheduleLocalNotification:locationNotification]; } 回调方法 - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{ //取消通知的注册 [application cancelLocalNotification:notification]; } 远程通知(Push通知)APNS推送机制（Apple Push Notification Service） Provider：程序的后台服务器。 上图分为三阶段： 第一阶段：应用程序的服务器端把要发送的消息、目的iPhone的标识打包，发给APNS。 第二阶段：APNS在自身的已注册Push服务的iPhone列表中，并把消息发送到iPhone。 第三阶段：iPhone把发来的消息传递给应用程序，并按照规定弹出Push通知。 APNS推送通知的详细流程 APP注册APNS消息推送，iOS向APNS Server 请求获取device token APNS向APP发送device token ，APP接受device token APP向程序的服务器端发送device token 程序服务器端发送Push通知到APNS APNS向APP发送Push通知 远程推送操作过程 APP启动过程中，注册远程通知 1[[UIApplication sharedApplication] registerForRemoteNotificationTypes:UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert| UIRemoteNotificationTypeSound]; 若注册成功，回调方法 123-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;NSLog(@&quot;%@&quot;, deviceToken);&#125; App获取device token 后，将device token 发送到自己的服务端。 APNS服务器得到JSON串后，向App发送通知消息，App调用回调方法 123 -(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; NSLog(@&quot;%@&quot;, userInfo);//从userInfo获得推送信息内容&#125; 客户端的开发cer文件 provisioning文件的生成 下载生成的cer文件和provi文件，双击导入Xcode，在build setting中code signing一栏中选择这两个文件的名称，这样就可以将支持push的app部署到真机中。然后消息推送： 客户端对推送消息的处理分为两种情况 在App没有运行的情况下，系统受到推送消息，用户点击推送消息，启动App。此时，不会执行前面提到的didReceiveRemoteNotification方法，而是App的applicationDidFinishLaunching方法中进行推送处理，通过以下代码可以获取推送消息中数据： Dictionary *userInfo =[launchOptions objectForKey:UIApplicationLaunchOp￼tionsRemoteNotificationKey]; 当App处于前台，系统受到推送消息，此时系统不会推送消息提示，会直接触发application:(UIApplication )application didReceiveRemoteNotification:(NSDictionary )userInfo方法，推送数据在userInfo中。 当App处于后台时，如果系统收到推送消息时，当用户点击推送消息时，会执行application: (UIApplication )application didReceiveRemoteNotification:(NSDictionary )userInfo方法，此时AppDelegate中方法的执行顺序为：applicationWillEnterForeground，applicationWillEnterForeground，applicationDidBecomeActive","tags":[{"name":"Local/Romote Notification","slug":"Local-Romote-Notification","permalink":"https://github.com/xiao-xi/tags/Local-Romote-Notification/"}]},{"title":"LLDB","date":"2015-01-30T13:22:51.000Z","path":"2015/01/30/LLDB－Xcode调试/","text":"Xcode调试基础如下图：调试视图包括顶部调试命令栏，左边变量视图，右边控制台。调试器工具栏从左到右功能分别是：\u000f断点是否有效，跳到下一个断点，单步执行，进入方法内部，跳出当前方法到上一个方法 定制断点满足条件的断点 i == 500 时代码暂停执行 根据以上选项可选择不同提示，Log Message 将消息写入日志，Sound 播放声音，若勾选Automatically continue after evaluating ，则会在播放声音或写入日志后不暂停执行代码 条件综合使用的断点 该断点的作用是：当 i == 500，打印self.view的信息，同时ls查看根路径下的目录,输出a的值，并且播放声音且不停止执行代码 断点类型 符号断点（Symbolic Breakpoint）该断点用于捕获特定方法或函数的所有方法 捕获viewDidLoad方法 异常断点 （All Exceptions） 异常断点，在发生异常时触发。通常会通过设置一个全局的异常断点，可提供比崩溃更详细的栈跟踪信息。有时候，异常断点能直接指出崩溃的根源。调试期间可以始终确保有一个全局的异常断点是一种最佳的实践。 LLDB调试 p （printf）打印标量表达式（eg a+b）或结构（CGRect）的值。po （print object）打印对象及其描述，可以查看特定内存的地址，也可以指定对象名。 list X：打印指定行后的10行代码。通过参数 -X可以指定断点前多少行代码 step （S）下一行 continue（\u0005C）越过断点继续执行 fin 执行到当前方法末尾 kill 终止执行程序","tags":[{"name":"Xcode调试","slug":"Xcode调试","permalink":"https://github.com/xiao-xi/tags/Xcode调试/"}]},{"title":"background_task","date":"2015-01-30T12:39:22.000Z","path":"2015/01/30/后台任务/","text":"简述iOS于2008年⾯面世时,只能有⼀一个第三⽅方应⽤用处于活动状态(位于前台)。这意味着应⽤用需要执 ⾏行的任务都必须位于前台的时候完成,否则任务将暂停并在应⽤用下次启动的时候执⾏行。iOS4推 出后,向第三⽅方应⽤用提供了后台功能。鉴于iOS设备的系统资源有限,以及省电,对后台处理有 ⼀一些限制,就是不能干扰前台应⽤用,也不能消耗太多电量。 iOS支持后台任务处理方式： 在后台完成耗时任务。这种方式适用于完成大量数据的下载或更新等任务，他们需要的时间超过了用户与应用交互的时间。 执行iOS允许的后台活动，如播放音乐、与蓝牙设备互交、监测GPS数据以获得位置发生重大变化、位置永久性网络连接让VoIP型应用能够正常运行。 检查设备是否支持后台任务在编写使用多任务功能的代码时，必须检查设备是否支持多任务 123UIDevice* device = [UIDevice currentDevice]; if (! [device isMultitaskingSupported]) &#123; NSLog(@&quot;当前设备不⽀支持多任务.&quot;); return;&#125; 在后台完成任务要在后台执⾏行任务,应告诉应⽤用这项任务需要能够在后台运⾏行。另外,还应考虑需要多少内存 以及多⻓长时间才能完成。如果任务完成需要的时间超过10-15分钟,很可能任务还未完成应⽤用就 被终⽌止了。所以任务应该包含处理提前终⽌止的逻辑,并能够在重新启动应⽤用后继续执⾏行。操作 系统给应⽤用指定⼀一段时间,供它完成后台任务,但如果如果操作系统发现资源紧缺,也可能提 早终⽌止应⽤用。 后台任务的通用执行过程： 向应用请求后台任务标识符，并指定一个用来处理终止程序的快。 仅当应⽤用完了后台时间,或系统发现资源使用率过⾼进⽽决定终⽌应⽤时,终⽌处理程序才会被调⽤用。 执⾏后台任务逻辑。这包括从请求后台任务标识符到结束后台任务之间的所有代码。 让应用结束后台任务，并让后台标识符失效。 获取后台任务标识符获取后台任务标识符同时制定终止处理程序块，使用__block 是为了block内部要对其修饰的变量修改。 12345__block NSInteger counter = 0;__block UIBackgroundTaskIndentifier bTaskIndentifier = [[UIApplication shareApplication] beginBackgroundTaskWithExpirationHandler:^&#123; ...&#125;]; 终止处理程序系统在指定的时间或资源⽤完后,将调⽤后台任务的终止处理程序。应用即将关闭前,将在主程中调⽤用终处理程序。给终⽌止处理程序提供的时间不多(最多几秒),所以它执⾏行的操作应尽可能少。 12 __block UIBackgroundTaskIdentifier bTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler: ^&#123; [[UIApplication sharedApplication] endBackgroundTask:bTask];//让应用指导后台任务结束 bTask = UIBackgroundTaskInvalid;//让后台任务标识符失效 &#125;]; 执行后台任务获取后台任务标⽰符后,就可以开始在后台执⾏行任务了。再执⾏行后台任务过程中,注意从应⽤那⾥获取后台任务余下的时间。可据此决定是否接着执⾏其他的代码。通常在余下的时间还有几秒时终⽌止后台任务,让它有时间执⾏行扫尾工作。后台任务完成后,还需要做两项重要⼯作: 1. 对共享应⽤用实例调用endBackgroundTask 让应⽤用知道后台任务已结束;2. 将变量bTask设置为UIBackgroundTaskInvalid ,让这个后台任务标⽰示符⽆无效。从获取后台任务标示符到结束后台任务之间的所有代码将在后台执行。 12345678910111213141516__block UIBackgroundTaskIdentifier bTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler: ^&#123; [[UIApplication sharedApplication] endBackgroundTask:bTask];//让应用指导后台任务结束 bTask = UIBackgroundTaskInvalid;//让后台任务标识符失效 &#125;]; NSInteger timeDuration = 1 * 60;NSLog (@&quot;Background task starting , task ID is %u&quot;,bTask);for (int counter = 0; counter &lt;= timeDuration;counter ++ )&#123; [NSThread sleepForTimeInterval:1]; //剩余运行时间 NSTimerInterval remainingTime = [[UIApplication sharedApplication] backgroundTimeRemaining]; if (remainingTime == DBL_MA)&#123; NSLog(@&quot;Background Processed %d. Still in foreground.&quot;,counter); &#125;else &#123; NSLog(@&quot;Background Processed %d. Time remaining is: %f&quot;,counter,remainingTime); &#125;&#125; dispatch_sync(dispatch_get_main_queue() &#123; [self.backgroundButton setEnabled:YES]; [self.backgroundButton setTitle:@&quot;Start Background Task&quot; forState:UIControlStateNorm];&#125; [[UIApplication sharedApplication] endBackgroundTask:bTask]; bTask = UIBackgroundTaskInvalid; 实现后台任务iOS⽀支持⼀组具体的后台任务,这些活动可不断地进⾏下去,不像使⽤后台任务标示符那样受到限制。这些活动不受时间上的限制,注意这些活动不应使用过多的系统资源,以避免被操作系统强⾏终⽌止。 后台活动类型 后台播放音频 跟踪设备位置 支持ip语音应用 现在‘报刊杂志’应用的新内容 与外置或蓝牙配件通信 在后台取回内容 使用推送通知启动后台下载￼￼","tags":[{"name":"background_task","slug":"background-task","permalink":"https://github.com/xiao-xi/tags/background-task/"}]},{"title":"SVN","date":"2015-01-27T12:44:05.000Z","path":"2015/01/27/SVN使用/","text":"svn 查看log$ svn log 查看SVN信息$ svn info 查看当前SVN关联目录下的文件改动$ svn st 提交代码$ svn ci file.m file2.m -m “提交file.m 和 file2.m” 比较某个文件与SVN上代码的改动$ svn diff file.m //查看file.m 的变化，此命令只显示代码段的不同 注释 比较两个文件或两个工程的差异，可使用Xcode工具filemerge 打开方式：右击Xcode -&gt; open developer tool -&gt; filemerge 删除svn服务器代码的某个文件$ svn del file.m //删除file.m这个文件,之后需要svn ci -m “提交删除的文件” 增加一个新文件$ svn add file.m //并提交 注意添加或删除某些名称中带@符号的文件，需要在其后面加个@，eg：添加scree@2x.png的命令 $ svn add screen@2x.png@","tags":[{"name":"SVN","slug":"SVN","permalink":"https://github.com/xiao-xi/tags/SVN/"}]},{"title":"cocoapods","date":"2015-01-17T10:55:26.000Z","path":"2015/01/17/cocoapods使用/","text":"简介 cocoapods  CocoaPods项目源码 安装 使用MAC自带的ruby下的gem命令： 12$ sudo gem install cocoapods$ pod setup 在执行pod setup时，会输出Se\u0005tting up CocoaPods master repo,但是会执行很长时间，在此期间CocoaPods将它的信息下载到~/.cocoapods目录下，此时可以cd到该目录，使用du -sh 命令查看下载进度。使用镜像索引可以提高下载速度（下面有介绍）。 将ruby源替换成国内淘宝源 1234$ gem sources --remove https://rubygems.org/$ gem sources -a http://ruby.taobao.org/查看源是否替换成功$ gem sources -l 如果安装的CocoaPods不能使用，可以尝试更新gem (sudo gem update –system),更新Iterm(删除原有的iterm,下载并安装新版本的\u0005iterm)。 镜像索引所有的项目的PodSpec文件都托管在podSpec。第一次执行pod setup时，将这些索引文件更新到本地~/.cocoapods/目录下。该文件比较大，所以第一次更新比较慢。 akinkiu在gitcafe和occhina上建立了CocoaPods索引镜像。gitcafe和occhina都是国内服务器，在执行索引更新操作时会比较快。 CoaoaPods设置成gitcafe镜像： 123$ pod repo remove master$ pod repo add master https://gitcafe.com/akuandev/Specs.git$ pod repo update 将以上url改为http://git.oschina.net.akuandev/Specs.git即可使用occhina镜像。 用法 cd到以创建的项目的目录下执行以下命令 pod init (生成Podfile文件，编辑该文件，添加所要加入的第三方库的名称版本（版本可以不用加）) eg: pod ‘AFNetworking’, ‘~&gt; 2.0’ pod ‘JSONKit’ pod install (自动将加入的第三方库源码下载下来，且为项目设置号好\b相应的系统依赖和编译参数) 注意 使用CocoaPods生成的*.xcworkspace文件打开工程，而不是以前的*.xcodeproj文件。 每次修改了Podfile文件，都需要执行一次pod update命令。 pop install之后还生成的另一个文件Podfile.lock,该文件不能放在.gitignore文件中。该文件用来锁定当前各依赖库的版本，之后及时多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock文件。该文件可以在多人协作时，防止第三方库升级造成大家各自的第三方库的版本不一致。Podfile.lock 查找第三方库 查找CocoaPods管理是否有你想要的库，执行命令 pod search eg： pod search json 可查找与接送有关的所有库 生成第三方库帮助文档 使用CocoaPods生成第三方库的帮助文档并集成到Xcode中，可使用brew安装appledoc即可： 1brew install appledoc 其优点：将帮助文档集成到Xcode中，在敲代码时可以按住opt键查看相应帮助文档 不更新podspec CocoaPods在执行pod install 和 pod update 时，会默认更新podspec索引。禁止更新podspec的命令： 12$ pod install --no-repo-update$ pod update --no-repo-update 原理CocoaPods的原理是将所有的依赖库都放到一个名为Pods的项目中，然互让主项目依赖Pods项目。 Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖.a这个文件即可。 对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方的各个资源文件复制到目标目录中。 CocoaPods通过一个名为Pods.xcconfig的文件在编译的时候设置所有的参数和依赖。","tags":[{"name":"cocoaPods","slug":"cocoaPods","permalink":"https://github.com/xiao-xi/tags/cocoaPods/"}]},{"title":"viewController","date":"2015-01-17T05:43:19.000Z","path":"2015/01/17/viewController试图控制器/","text":"1.UIViewController生命周期几种方法调用时机 - (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil;当UIViewController在初始化加载xib文件时，该方法被调用。 - (void)loadView;当每次访问UIViewController的view(比如controller.view,self.view)并且view为nil，该方法就会被调用。 - (void)viewWillUnload; - (void)viewDidUnload; - (void)viewDidLoad;不管是通过xib文件还是重写loadView创建UIViewController的view，在view创建完毕后，最终都会调用该方法。 - (void)viewWillAppear:(BOOL)animated;当view将要呈现在UI界面上时会调用该方法。 - (void)viewDidAppear:(BOOL)animated;当view已经完全过渡到屏幕上时会调用该方法。 - (void)viewWillDisappear:(BOOL)animated;当view将要消失，或被覆盖、隐藏时会调用该方法。 - (void)viewDidDisappear:(BOOL)animated;当view已经完全消失，或被覆盖、隐藏时会调用该方法。 2.UIViewController xib的加载过程loadView默认实现就是在自定义的UIViewController类里不重写loadView方法，或者重写后只是在方法里简单实现[super loadView]。默认实现做了如下几个工作： 它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view 如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件 [[UIViewController alloc] initWithNibName:@”ViewController” bundle:nil]; 如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件 [[UIViewController alloc] init]; // 加载UIViewController.xib 如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下： self.view = [[[UIView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame] autorelease]; 3.几种控制器容器的优缺点1.UITabBarController(Tabbar底部标签式:Instagram、微信、微博)UITabBarController作为一种容器适合管理底部标签式（TabBar 如： Instagram、微信、微博）这种结构的APP 优点 清楚当前所在的入口位置 轻松在各入口间频繁跳转且不会迷失方向 直接展现最重要入口的内容信息（默认首页） 缺点功能入口过多时，该模式显得笨重不实用(超过5个的时候会将其他控制器添加到一个更多界面) 2.UINavigationController (Springboard跳板式:星巴克)UINavigationController作为一种容器适合管理跳板式（SpringBoard 如： 星巴克）这种结构的APP 优点 清晰展现各入口 容易记住各入口位置，方便快速找到 确定 无法在多入口间灵活跳转，不适合任务操作 容易形成更深的路径 不能直接展现入口内容 不能显示太多入口次级内容 3.UINavigationController做整体，融合TabBarController（List Menu列表式：知乎）优点 层次展示清晰 可展示内容较长的标题 可展示标题的次级内容 缺点 同级内容过多时，用户浏览容易产生疲劳 排版灵活性不是很高 只能通过排列顺序、颜色来区分各入口重要程度 4.UIScrollvIewController融合pageControl (Carousel旋转木马式:豆瓣同城)优点 单页面内容整体性强 线性的浏览方式有顺畅感、方向感 缺点 不适合展示过多页面 不能跳跃性地查看间隔的页面，只能按顺序查看相邻的页面 由于各页面内容结构相似，容易忽略后面的内容 5. Drawer抽屉式：豆瓣小组优点 兼容多种模式（页面内自有组织） 扩展性好 缺点 隐藏框架中其他入口 对入口交互的功能可见性(affordance)要求高 对排版要求高 6. Plus点聚式：Path优点 灵活 展示方式有趣 使界面更开阔 缺点 隐藏框架中其他入口 对入口交互的功能可见性(affordance)要求高 7.Gallery陈列馆式：多看，豆瓣电影优点 直观展现各项内容 方便浏览经常更新的内容 缺点 不适合展现顶层入口框架 容易形成界面内容过多，显得杂乱 设计效果容易呆板 8.Waterfall瀑布式优点 浏览时产生流畅体验 缺点 缺乏对整体内容的体积感，容易发生空间位置迷失 浏览一段时间后，容易产生疲劳感","tags":[{"name":"kinds of viewControllers","slug":"kinds-of-viewControllers","permalink":"https://github.com/xiao-xi/tags/kinds-of-viewControllers/"}]},{"title":"iOS打电话发短信","date":"2015-01-13T04:58:45.000Z","path":"2015/01/13/iOS打电话发短信/","text":"##打电话发信息 ###发短信 1234567891011121314151617*系统方法1.sms://电话号码,确定URL2.调用系统方法 * NSString *strURL = [NSString stringWithFormat:@&quot;sms://%@&quot;,self.textField.text]; * NSURL *msg = [NSURL URLWithString:strURL]; * [[UIApplication sharedApplication] openURL:msg];*代理方法 1. &lt;MessageUI.h&gt;头文件， 2. &lt;MFMessageComposeViewControllerDelegate&gt; 代理3. message.messageComposeDelegate = self;(delegete比 较特殊) 4.本身是导航控制器，所以要present或者dismiss ##打电话 12345678910111213141516171819202122232425262728293031323334353637383940*系统方法 1.tel://电话号码,确定URL2.调用系统方法 3.缺点：不能打电话前的询问和回到应用页面 * NSString *strURL = [NSString stringWithFormat:@&quot;tel://%@&quot;,self.textField.text]; * NSURL *msg = [NSURL URLWithString:strURL]; * [[UIApplication sharedApplication] openURL:msg];*用webView，可以有询问，也可以回到应用页面 * NSString *strURL = [NSString stringWithFormat:@&quot;telprompt://%@&quot;,self.textField.text]; * NSURL *tel = [NSURL URLWithString:strURL]; * NSURLRequest *request = [NSURLRequest requestWithURL:tel];* UIWebView *webView = [[UIWebView alloc]initWithFrame:self.view.bounds];* [wenView loadRequest:request]; * _webView = webView;*注意*：这里的webView生成成员变量，不执行 [self.view addSubview:webView] *另一种系统方法 * NSString *strURL = [NSString stringWithFormat:@&quot;telprompt://%@&quot;,self.textField.text]; * NSURL *tel = [NSURL URLWithString:strURL]; * [[UIApplication sharedApplication] openURL:tel];","tags":[]},{"title":"data-persistence","date":"2014-12-02T05:28:50.000Z","path":"2014/12/02/iOS数据持久化/","text":"Sandbox（沙盒机制） iOS中得沙盒机制（sandbox）是一种安全体系，它规定了应用程序只能在为该应用程序创建的文件夹内读取文件，不可以访问其他地方的内容。所有的非代码文件都保存在这个地方，如图片，声音，属性列表和文本文件等。 每个应用程序都在自己的沙盒内 不能随意跨越自己的沙盒去访问别的应用程序的沙盒内容 应用程序向外请求或接受数据都需要经过权限认证 一个沙盒中包含四部分 .app文件，即可运行的应用文件； Document，苹果建议将程序创建或程序浏览的文件数据保存在该目录下，iTunes备份和恢复时会包括该目录； Library，存储程序的默认设置或其它状态信息； Library/Caches，存放缓存文件，iTunes不会备份此目录，此目录下的文件不会在应用退出删除； tmp，创建和存放临时文件的地方，iTu不会备份此目录。 代码获取沙盒路径的方法 获取根目录 NSString *homePath = NSHomeDirectory(); 获取Document目录 NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES)[0]; 获取Cache目录 NSString *cachePath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask, YES)[0]; 获取Library目录 NSString *libPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask, YES)[0]; 获取tmp目录 NSString *tmpPath = NSTemporaryDirectory(); iOS数据持久化技术数据持久化既是，能将内存中的数据模型转换为存储模型，并能在将来需要时将存储模型还原为数据模型的一种机制。 说明 ： 通俗的\b讲，也就是将数据保存在非易失性的设备中，并且能在需要时恢复。针对苹果设备来说，就是从闪存到内存的过程。 iOS开发中数据持久化的方法 Row File APIs(C语言的文件操作，iOS的NSFilemanager) NSUserDefaults （默认保存文件在对应的程序包sandbox的目录下的library/Preferences） Plist(属性列表) NSCoding + Archiver&amp;Unarchiver (对象归档) SQLite （数据库） FMDB (对SQLite的封装) @property (nonatomic, strong) NSString *filePath;@property (nonatomic, strong) UITextField *textField;#define kFileName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@”test.txt” ROW APIsC语言文件操作### ROW APIs 创建文件路径 123456//创建文件存放路径（一般需要保存的文件存放在sandbox的Document目录下）- (void)setupPath&#123; NSString *documentDirectory = NSSearchPathForDirectorieInDomains(NSDocumentDirectory,NSUserDomainMask,YES)[0]; self.filePath = [documentDirectory stringByAppendingPathComponent:kFileName]; &#125; 文件的写入 123￼- (void)saveData ￼&#123; ￼// oc文件路径转化为c ￼const char *filePath = [_fileP\u0002ath UTF8String]; ￼// 打开文件 ￼FILE *fp = fopen(filePath, &quot;w+&quot;); ￼if (NULL == fp) &#123; perror(&quot;fopen&quot;); ￼return; &#125; ￼￼// 将_textFiled的内容写到文件 ￼const char *content = [_textField.text UTF8String]; ￼size_t size = fwrite(content, BUFSIZE, 1, fp); ￼fclose(fp); ￼if (size &gt; 0) &#123; ￼ NSLog(@&quot;Saved data successfully&quot;); ￼&#125; ￼&#125; 文件的读取 1234567891011- (void)loadData&#123; ￼// 文件路径 ￼const char *filePath = [_path UTF8String]; ￼NSLog(@&quot;%s&quot;, filePath); ￼// 打开文件 ￼FILE *fp = fopen(filePath, &quot;r&quot;); ￼if (fp == NULL) &#123; perror(&quot;fopen&quot;); return; ￼&#125; //读取文件内容到内存 char buf[BUSIZ] = &#123;0&#125;; //获取文件大小 fseek(fp,SEEK_END); long size = ftell(fp); fread(fp,size,1,buf); //赋值给_textField NSString *str = [NSString stringWithUTFString:str]; if(str != NULL &amp;&amp; ![str isEqualToString:@&quot;&quot;]);&#123; _textField.text = str; &#125; fclose(fp);&#125; OC NSFileManager文件管理器操作 创建文件路径 1234567891011121314//创建文件存放路径（一般需要保存的文件存放在sandbox的Document目录下）- (void)setupPath&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *documentDirectory = NSSearchPathForDirectorieInDomains(NSDocumentDirectory,NSUserDomainMask,YES)[0]; //创建文件目录 NSString *test = [documentDirectory stringByAppendingPathComponent:@&quot;test&quot;]; [fileManager createDirectoryAtPath:test withIntermediateDirectories:YES attributes:nil error:nil]; self.filePath = [documentDirectory stringByAppendingPathComponent:kFileName]; NSString *content = nil; if(![fileManager fileExistsAtPath:self.filePAth])&#123; [fileManager createFileAtPath:self.filePath contents:[content dataUsingEncoding:NSUTF*String] attributes:nil]; &#125;&#125; 文件的写入 12345678910- (void)saveData&#123; NSError *error; [self.textField.text writeToFile:self.filePath atomically:YE\u0005]; if(error)&#123; NSLog(@&quot;Error : %@&quot;,error); return; &#125; NSLog(@&quot;save data successfully&quot;);&#125; 文件的读取 1234567891011- (void)loadData&#123; NSError *error; NSString *content = [[NSString alloc]initWithContentsOfFile:self.filePath encoding:NSUTF*String error:&amp;error]; if(error)&#123; NSLog(@&quot;Error : %@&quot;,error); return; &#125; self.textField.text = content; NSLog(@&quot;load data successfully&quot;);&#125; NSUserDefaults&gt; 直接使用原始的文件操作API,不管是C语言的还是OC的都不太方便 Cocoa会为每个app自动创建一个数据库,用来存储App本身的偏好设置,如:开关值,音量值之类的少量信息 NSUserDefaults使用时用 [NSUserDefaults standardUserDefaults] 接口获取单例对象 NSUserDefaults本质上是以Key-Value形式存成plist文件,放在App的 Library/Preferences目录下 这个文件是不安全的,所以千万不要用NSUserDefaults来存储密码之类的敏感信息,用户名和密码应该使用KeyChains来存储 文件的写入 123 - (void)saveData &#123; ￼NSUserDefaults *userDefaults = [NSUserDefaults ￼standardUserDefaults]; float progress = [self.progressTextField.text floatValue]; ￼[userDefaults setFloat:progress forKey:@&quot;progress&quot;]; ￼[userDefaults setObject:self.inputTextField.text ￼forKey:@&quot;input&quot;]; ￼database // keeps the in-memory cache in sync with a user’s defaults ￼￼[userDefaults synchronize]; ￼￼ &#125; 文件的读取 12- (void)loadConfig ￼&#123; ￼NSUserDefaults *userDefaults = [NSUserDefaults ￼standardUserDefaults]; ￼self.toggle.on = [userDefaults boolForKey:@&quot;toggle&quot;]; self.progressView.progress = [userDefaults floatForKey:@&quot;progress&quot;]; self.progressTextField.text = [NSString stringWithFormat:@&quot;%.2f&quot;, self.progressView.progress]; self.inputTextField.text = [userDefaults stringForKey:@&quot;input&quot;];&#125; 说明: 对NSUserDefaults单例对象的操作,实质上还是对PList文件 (Library/Preferences/.plist)的读写,只是Apple帮我们封装好了 读写方法。 Plist&gt; NSUserDefaults只能读写Library/Preferences/.plist这个 文件 PList文件是XML格式的,只能存放固定数据格式的对象 PList文件支持的数据格式有NSString, NSNumber, Boolean, NSDate, NSData, NSArray,和NSDictionary。其中,Boolean格式事实上以[NSNumber numberOfBool:YES/NO];这样的形式表示。NSNumber支持float和int两种格式。 创建文件路径 123456- (void)setUpPlist&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *documentDirectory = NSSearchPathForDirectorieInDomains(NSDocumentDirectory,NSUserDomainMask,YES)[0]; self.filePath = [documentDirectory stringByAppendingPathComponent:@&quot;test.plist&quot;]; &#125; 写入plist文件 123456- (void)saveData&#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; ￼dict[@&quot;textField&quot;] = _textField.text; ￼if (![dict writeToFile:_path atomically:YES]) &#123; ￼NSLog(@&quot;Error!!!&quot;); return; ￼&#125;&#125; plist文件的读取 1234 - (void)loadData &#123; NSMutableDictionary *dict = [NSMutableDictionary ￼dictionaryWithContentsOfFile:_path]; ￼NSString *content = dict[@&quot;textField&quot;]; ￼ if (content &amp;&amp; content.length &gt; 0) &#123; ￼_textField.text = content; ￼ &#125; &#125; Archiver&amp;Unarchiver&gt; NSUserDefaults和Plist文件支持常用数据类型,但是不支持自定义的数据对象 Cocoa提供了NSCoding和NSKeyArchiver两个工具类,可以把我们自定义的对象编码 成二进制数据流,然后存进文件里面 NSCoding协议 123//解档，解码。解档之后会生成一个该类的对象（解码后对模型的属性赋值）- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; if (self) &#123; self.name = [aDecoder decodeObjectForKey:kNameKey]; self.age = [aDecoder decodeIntForKey:kAgeKey]; self.studyID = [aDecoder decodeObjectForKey:kStudyIDKey]; &#125; return self; ￼&#125; 123//归档，编码 （将模型的属性编码）- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; if (self) &#123; self.name = [aDecoder decodeObjectForKey:kNameKey]; self.age = [aDecoder decodeIntForKey:kAgeKey]; self.studyID = [aDecoder decodeObjectForKey:kStudyIDKey]; &#125; return self; ￼&#125; ---- 保存数据 12￼- (void)saveData&#123; _student = [[YMStudent alloc] init]; ￼_student.name = _name.text; ￼_student.age = [_age.text intValue]; ￼_student.studyID = _studyID.text; ￼if ([NSKeyedArchiver archiveRootObject:_student toFile:self.filePath]) &#123; ￼ NSLog(@&quot;Archive successfully!&quot;); ￼&#125;&#125; 读取数据 123￼- (void)loadData&#123; _student = [NSKeyedUnarchiver unarchiveObjectWithFile:self.filePAth]; ￼if (student != nil) &#123; _name.text = student.name; _age.text = ￼[@(student.age) stringValue]; _studyID.text = ￼student.studyID; ￼ NSLog(@&quot;Archive successfully!&quot;); ￼&#125;&#125; SQLiteSQLite SQLite shell commandSQLite shell command SQLite usage创建数据库连接对象: sqlite3 创建预编译语句对象:sqlite3_stmt 打开数据 sqlite3_open() 将SQL语句转换为预编译语句对象 sqlite3_prepare_v2() 执行预编译语句，每次处理一次，不需要返回值的语句（如INSERT,UPDATE,DELETE）,只需要执行该函数即可 sqlite3_step() 获取数据库中得不同类型的值 sqlite3_column_blob() sqlite3_column_bytes() sqlite3_column_bytes16() sqlite3_column_count() sqlite3_column_double() sqlite3_column_int() sqlite3_column_int64() sqlite3_column_text() sqlite3_column_text16() sqlite3_column_type() sqlite3_column_value() 销毁有sqlite3_prepare_v2()函数创建的预处理语句对象 sqlite3_finalize() 关闭数据库(即销毁数据库连接对象) sqlite3_close() FMDB&gt; FMDB Document Download FMDB FMDB数据库操作类对sqlite3的操作进行了便利的封装并保证了多线程下的安全地操作数据库 FEMDB有三个主要的类 FMDatabase - 表示一分单独的SQLite数据库，用来执行SQLite的命令 FMResultSet - 表示FMDatabase执行查询结果集 FMDatabaseQueue - 在多线程中执行多个查询或更新使用该类是线程安全的 数据库的创建#define kDBFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@”database.sqlite” NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,￼NSUserDomainMask, YES)[0]; NSString *DBPath = [docPath stringByAppendingPathComponent:kDBFileName]; FMDatabase *database = [FMDatabase databaseWithPath:DBPath]; 打开数据库if(![database open]){ NSLog(@&quot;Open database failed !&quot;); return; } 执行更新 executeUpdate 一切不是SELECT命令的命令都是为更新。包括CREATE，UPDATE，INSERT，ALTER等。 执行结果返回一个BOOL值。YES表示成功，NO表示失败。可以调用 -lastErrorMessage和 -lastErrorCode方法获取更多的信息。 执行查询 executeQuery 执行结果返回FMResultSet对象，失败返回nil。同样可以调用-lastErrorMessage和 -lastErrorCode方法获取更多的信息。获得的FMResultSet对象rs后，既是只有一条记录，一样使用[rs next]; eg: FMResultSet *rs = [db executeQuery:@&quot;SELECT Name, Age, FROM PersonList&quot;]; while ([rs next]) { ￼NSString *name = [rs stringForColumn:@&quot;Name&quot;]; ￼int age = [rs intForColumn:@&quot;Age&quot;]; } FMResultSet根据类型提取数据- objectForColumnName: ￼- longForColumn: ￼- nlongLongIntForColumn: ￼- boolForColumn: ￼- doubleForColumn: ￼- stringForColumn: ￼- dateForColumn: ￼- dataForColumn: ￼- dataNoCopyForColumn: ￼- UTF8StringForColumnName: ￼ 以上方法，都有个{type}ForColumnIndex:版本，根据column的位置提取数据 有些时候,只是需要query某一个row里特定的一个数值(比如只是要找John的年龄),FMDB 提供了几个比较简便的方法。这些方法定义在FMDatabaseAdditions.h,如果要使用,记得先 import进来 //找地址 NSString *address = [db stringForQuery:@&quot;SELECT Address FROM PersonList ￼WHERE Name = ?&quot;,@&quot;John”]; ￼NSString *address = [db stringForQuery:@&quot;SELECT Address FROM PersonList WHERE Name = ?&quot;,@&quot;John”]; ￼//找年齡 ￼int age = [db intForQuery:@&quot;SELECT Age FROM PersonList WHERE Name = ?&quot;,@&quot;John”]; 关闭数据库 [FMDatabase close]; 数据库的批量操作使用FMDatabase 的executeStatements:或者executeStatements:withResultBlock:(是否需 要返回结果) NSString *sql = @&quot;create table bulktest1 (id integer primary key ￼autoincrement, x text);&quot; &quot;create table bulktest2 (id integer primary key autoincrement, y text);&quot; &quot;create table bulktest3 (id integer primary key autoincrement, z text);&quot; &quot;insert into bulktest1 (x) values (&apos;XXX&apos;);&quot; &quot;insert into bulktest2 (y) values (&apos;YYY&apos;);&quot; &quot;insert into bulktest3 (z) values (&apos;ZZZ&apos;);&quot;; ￼success = [database executeStatements:sql]; 或者 sql = @&quot;select count(*) as count from bulktest1;&quot; }]; ￼&quot;select count(*) as count from bulktest2;&quot; ￼&quot;select count(*) as count from bulktest3;&quot;; ￼success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary ￼*dictionary) { ￼NSInteger count = [dictionary[@&quot;count&quot;] integerValue]; ￼XCTAssertEqual(count, 1, @&quot;expected one record for dictionary %@&quot;, ￼dictionary); ￼return 0; }]; 参数绑定**INSERT INTO myTable VALUES (?, ?, ?)** 问号只是占位,执行操作可以使用NSArray, NSDictionary, or a va_list来匹配参数你也可以选择使用命名参数语法:INSERT INTO myTable VALUES (:id, :name, :value)参数名必须以冒名开头。SQLite本身支持其他字符($,@),Dictionary key的内部实现是冒号 开头。注意你的NSDictionary key不要包含冒号 NSDictionary *argsDict = @{@&quot;name&quot;:@&quot;Jason&quot;}; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (:name)&quot;withParameterDictionary:argsDict]; FMDatabaseQueue 及线程安全不能使⽤用同⼀个FMDatabase在不同线程中操作,多线程的操作是通过FMDatabaseQueue实现 首先创建队列,然后把单任务包装到事务里,串行执行 FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath]; [queue inDatabase:^(FMDatabase *db) { [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]]; FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;]; while([rs next]) { ... } 事务的回滚:(当前的队列的操作的取消） [queue inTransaction:^(FMDatabase *db, BOOL *rollback) { [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]]; if (whoopsSomethingWrongHappened) { } *rollback = YES; return; // etc... [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:4]]; ￼}]; ￼FMDatabaseQueue会在同一个队列里 同步执行任务, GCD也会按它接收的块的顺序来执行 关于Setting Bundles&gt; Setting Bundle的概念更多地应该是在App的配置选择上 Setting Bundle可以给用户提供一个从《设置》应用里去配置应用程序的方式 从开发者的角度来看,一般需要频繁修改的配置选项,如游戏的音量和控制选项等最好 放到app内部的设置页里,而类似于邮箱应用中的邮件地址和服务器的设置等不需要频 繁更改的配置项可以放到Setting Bundle里 从《设置》应用中进行设置,实际上是操作iOS配置系统中的应用程序域(Application Domain),是持久的 iOS的配置系统中存在如下一些域,将来查询时严格按照如下列出域的顺序进行查找 Domain State NSArgumentDomain volatile(易失的) Application（Identified by the app’s identifier） persistent(持久的) NSGlobalDomain persistent Languages(Identified by the language names) volatile NSRegisterationDomain volatile registerDefaults:方法是在NSRegistrationDomain域上进行配置的,所以仅仅是存在于 内存中的,易失的","tags":[{"name":"Data Persistence","slug":"Data-Persistence","permalink":"https://github.com/xiao-xi/tags/Data-Persistence/"}]},{"title":"AFNetworking","date":"2014-11-29T13:55:09.000Z","path":"2014/11/29/AFNetworking/","text":"下载AFNetworking开源代码点击链接：AFNetworking Architecture NSURLConnection AFURLConnectioinOperatioin AFHTTPRequestOperation AFHTTPRequestOperationManager NSURLSession(iOS 7 /Mac OS 10.9) AFURLSessionManager AFHTTPSessionManager Serialization AFURLRequestSerialization AFHTTPRequestSerialization AFJSONRequestSerialization AFPropertyListRequestSerialization AFURLResponseSerialization AFHTTPResponseSerialization AFJSONResponseSerialization AFXMLParserResponseSerialization AFXMLDocumentResponseSerialization (MAC OS X) AFPropertyListResponseSerialization AFImageResponseSerializer AFCompoundResponseSerializer Additional Functionality AFSecurityPolicy AFNetworkReachabilityManager Usage#define kBaseURL @”http://afnetworking.sinaapp.com“ 123requestSerializer 默认是 [AFHTTPRequestSerializer serializer];responseSerializer 默认是 [AFJSONResponseSerializer serializer]; AFHTTPRequestOperationNSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_get.json&quot;]; NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;}; NSURLRequest *request = [[AFHTTPRequestSerializer serializer] requestWithMethod:@&quot;GET&quot; URLString:urlStr parameters:parameters error:nil]; AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc]initWithRequest:request]; op.responseSerializer = [AFJSONResponseSerializer serializer]; [op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@&quot;response object : %@&quot;,responseObject); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@&quot;Error : %@&quot;,error); }]; [[NSOperationQueue mainQueue] addOperation:op]; ----------------------------------------------------- 结果： Success: response object : { data = { foo = bar; }; success = 1; } Error:{ &quot;errors&quot;:&quot;Parameter error!&quot;, &quot;success&quot;:false } ----------------------------------------------------- AFHTTPRequestOperationManagerGET RequestNSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_get.json&quot;]; NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;}; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; [manager GET:urlStr parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@&quot;response object : %@&quot;,responseObject); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@&quot;Error : %@&quot;,error); }]; ----------------------------------------------------- 结果： Success: response object : { data = { foo = bar; }; success = 1; } Error:{ &quot;errors&quot;:&quot;Parameter error!&quot;, &quot;success&quot;:false } ----------------------------------------------------- POST URL-Form-RequestNSString *httpUrlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_http.json&quot;]; NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;}; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; [manager POST:httpUrlStr parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@&quot;response object : %@&quot;,responseObject); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@&quot;Error : %@&quot;,error); }]; NSString *jsonUrlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_json.json&quot;]; [manager POST:jsonUrlStr parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@&quot;Response object : %@&quot;,responseObject); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@&quot;Error : %@&quot;,error); }]; ----------------------------------------------------- 结果： Success: response object : { data = { foo = bar; }; success = 1; } Error:{ &quot;errors&quot;:&quot;Parameter error!&quot;, &quot;success&quot;:false } ----------------------------------------------------- POST Multi-Part-RequestNSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;upload2server.json&quot;]; NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;}; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; [manager POST:urlStr parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) { NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@&quot;b_Aquarius&quot; withExtension:@&quot;jpg&quot;]; [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; fileName:@&quot;constellation.jpg&quot; mimeType:@&quot;image/jpeg&quot; error:nil]; fileURL = [[NSBundle mainBundle] URLForResource:@&quot;b_Aries&quot; withExtension:@&quot;png&quot;]; [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; fileName:@&quot;constellation.png&quot; mimeType:@&quot;image/png&quot; error:nil]; } success:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@&quot;Response object : %@&quot;,responseObject); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@&quot;Error : %@&quot;,error); }]; ----------------------------------------------------- 结果： Success: Response object : { data = ( { name = &quot;constellation.jpg&quot;; url = &quot;http://afnetworking-userdomain.stor.sinaapp.com/constellation.jpg&quot;; }, { name = &quot;constellation.png&quot;; url = &quot;http://afnetworking-userdomain.stor.sinaapp.com/constellation.png&quot;; } ); success = 1; } ----------------------------------------------------- AFURLSessionManagerCreating a Download Task/#define kDownloadUrl @”http://music.baidu.com/data/music/file?link=http://yinyueshiting.baidu.com/data2/music/346495/3464861417179661128.mp3?xcode=91aea20a92711d3d83f3f76a0952eb4b63b77ba183a87289&amp;song_id=346486“ kDownloadUrl 是下载链接 NSURL *url = [NSURL URLWithString:kDownloadUrl]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSProgress *progress = nil; NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:&amp;progress destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) { NSString *filePath = @&quot;/Users/qingyun/Desktop&quot;; NSString *newFielPath = [filePath stringByAppendingPathComponent:response.suggestedFilename]; NSLog(@&quot;name : %@&quot;,response.suggestedFilename); return [NSURL fileURLWithPath:newFielPath]; } completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) { if (error) { NSLog(@&quot;Error : %@&quot;,error); }else{ NSLog(@&quot;File path : %@&quot;,filePath); } }]; [downloadTask resume]; ----------------------------------------------------- 结果： Success: File path : file:///Users/qingyun/Desktop/Only%20Love.mp3 ----------------------------------------------------- Creation a Upload Task NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;upload2server.json&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSProgress *progress = nil; NSString *filePath = @&quot;file:///Users/qingyun/Desktop/xml&amp;json.pdf&quot;; NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:[NSURL fileURLWithPath:filePath] progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) { if (error) { NSLog(@&quot;Error : %@&quot;,error); }else{ NSLog(@&quot;Response objecct : %@&quot;,responseObject); } }]; [uploadTask resume]; ----------------------------------------------------- 结果： Success：Response objecct : { success = 1; } ----------------------------------------------------- Creation a Upload Task For Multi-Part Request, With ProgressNSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;upload2server.json&quot;]; NSURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@&quot;POST&quot; URLString:urlStr parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) { NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@&quot;b_Cancer&quot; withExtension:@&quot;png&quot;]; [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; fileName:@&quot;Cancer.png&quot; mimeType:@&quot;image/png&quot; error:nil]; fileURL = [NSURL URLWithString:@&quot;file://Users/qingyun/Desktop/xml&amp;json.pdf&quot;]; [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; error:nil]; } error:nil]; NSProgress *progress = nil; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) { if (error) { NSLog(@&quot;Error : %@&quot;,error); }else{ NSLog(@&quot;Response objecct : %@&quot;,responseObject); } }]; [uploadTask resume]; ----------------------------------------------------- 结果： Success:Response objecct : { data = ( { name = &quot;Cancer.png&quot;; url = &quot;http://afnetworking-userdomain.stor.sinaapp.com/Cancer.png&quot;; } ); success = 1; } ----------------------------------------------------- Creation a Data TaskNSURL *url = [NSURL URLWithString:[kBaseURL stringByAppendingPathComponent:@&quot;response.json&quot;]]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) { if (error) { NSLog(@&quot;Error : %@&quot;,error); }else{ NSLog(@&quot;response object : %@&quot;,responseObject); } }]; [dataTask resume]; ----------------------------------------------------- 结果： Success： response object : { data = &quot;This is a json data.&quot;; success = 1; } ----------------------------------------------------- AFHTTPSessionManagerGET RequestNSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_get.json&quot;]; NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;}; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSURLSessionDataTask *dataTask = [manager GET:urlStr parameters:parameters success:^(NSURLSessionDataTask *task, id responseObject) { NSLog(@&quot;response object : %@&quot;,responseObject); } failure:^(NSURLSessionDataTask *task, NSError *error) { NSLog(@&quot;Error : %@&quot;,error); }]; [dataTask resume]; ---------------------------------------------------- 结果： Success :response object : { data = { foo = bar; }; success = 1; } ---------------------------------------------------- POSTRequestNSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_http.json&quot;]; NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;}; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSURLSessionDataTask *dataTask = [manager POST:urlStr parameters:parameters success:^(NSURLSessionDataTask *task, id responseObject) { NSLog(@&quot;response object : %@&quot;,responseObject); } failure:^(NSURLSessionDataTask *task, NSError *error) { NSLog(@&quot;Error : %@&quot;,error); }]; [dataTask resume]; ----------------------------------------------------- 结果： Success:response object : { data = { foo = bar; }; success = 1; } ----------------------------------------------------- HEADRequestNSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_http.json&quot;]; NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;}; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSURLSessionDataTask *dataTask = [manager HEAD:urlStr parameters:parameters success:^(NSURLSessionDataTask *task) { NSLog(@&quot;Task : %@&quot;,task); } failure:^(NSURLSessionDataTask *task, NSError *error) { NSLog(@&quot;Task : %@ Error : %@&quot;,task,error); }]; [dataTask resume]; ---------------------------------------------------- 结果： Success： Task : &lt;__NSCFLocalDataTask: 0x8d77b10&gt; { completed } ---------------------------------------------------- AFNetworkReachabilityManager/* *AFNetworkReachabilityStatusNotReachable = 0, *AFNetworkReachabilityStatusReachableViaWWAN = 1, *AFNetworkReachabilityStatusReachableViaWiFi = 2 */ NSArray *array = @[@&quot;不可达&quot;,@&quot;2G/3G/4G&quot;,@&quot;wi-fi&quot;]; [AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager]; [self.manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) { UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;网络检测&quot; message:[NSString stringWithFormat:@&quot;%@&quot;,array[status]] delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil]; [alert show]; }]; ----- [manager startMonitoring]; [manager stopMonitoring];","tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"https://github.com/xiao-xi/tags/AFNetworking/"}]},{"title":"UIScrollView","date":"2014-11-27T05:26:50.000Z","path":"2014/11/27/UIScrollView/","text":"ScrollView 不能滑动的常见原因 contentsize 未设置 scrollEnabled = NO; userInteractionEnabled = NO; 未取消autolayout contentInset属性控制scrollView四周可以多出的滑动长度，默认为四个参数均为0，急不可以滑动超出contentSize以外的区域 -（UIView ）viewForZoomingInScrollView:(UIScrollView )scrollView;该方法实现对返回的视图进行缩放大小，放回的视图必须是scrollView的子视图 diractionalLockEnabled该属性设置为YES时可以控制在滑动scrollView时不会有晃动的效果，即当用户的滑动的方向不是正方向时，scrollView仍然只是针对某一个方向滑动 pagingEnable该属性设置为YES时，可以控制用户滑动一下只翻一页。","tags":[{"name":"UIScorllView","slug":"UIScorllView","permalink":"https://github.com/xiao-xi/tags/UIScorllView/"}]},{"title":"UI_notes","date":"2014-11-13T08:20:58.000Z","path":"2014/11/13/UI笔记/","text":"UIView常用属性及方法常用属性NSInteger tag; CGRect frame; CGRect bounds; CGPoint center; CGAffineTransform transform; BOOL multipleTouchEnable; BOOL exclusiveTouch; UIView *superView; NSArray *subViews; UIWindow *window; UIColor *backgroundColor; CGFloat alpa; BOOL opaque; BOOL hidden; 常用方法类方法1+ (id)initWithFrame:(CGRect)frame; 实例方法123456- (void)removeFromSuperview;- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;- (void)addSubview:(UIView *)view;- (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview;- (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview; UIView常见子类UIControl常用属性BOOL enable; BOOL selected; BOOL highlighted; UIControlState state;&lt;readonly&gt; BOOL touchInside;&lt;readonly&gt; 实例方法1234- (void)addTarget:(id)target action:(SEL)action forControlEvent:(UIControlEvent)controlEvent;- (void)removeTarget:(id)target action:(SEL)action forControlEvent:(UIControlEvent)controlEvent;- (void)sendAction:(SEL)action to:(id)target forEvent:(UIEvent)event;- (void)sendActionsForControlEvents:(UIControlEvent)controlEvents; UIControl常见子类UIButton常用属性UIButtonType buttonType;&lt;readonly&gt; NSString *currentTitle;&lt;readonly&gt; UIColor *currentColor;&lt;readonly&gt; UIImage *currentImage;&lt;readonly&gt; UIImage *currentBackgroundImage;&lt;readonly&gt; NSAttributedString *currentAttributedTitle;&lt;readonly&gt; 类方法1+ (id)buttonWithType:(UIButtonType)buttonType; 实例方法12345678910- (void)setTitle:(NSString *)title forState:(UIControlState)state;- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state;- (void)setImage:(UIImage *)image forState:(UIControlState)state;- (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;- (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state;- (NSString *)titleForState:(UIControlState)state;- (UIColor *)titleColorForState:(UIControlState)state;- (UIImage *)imageForState:(UIControlState)state;- (UIImage *)backgroundImageForState:(UIControlState)state;- (NSAttributedString *)attributedStringForState:(UIControlState)state; UISlider常见属性float value; float minimumValue; float maximumValue; UIImage *minimumValue; UIImage *maximumValue; BOOL continuous; UIColor *minimumTrackTintColor; UIColor *maximumTrackTintColor; UIColor *thumbTintColor; readonly UIImage *currentThumbImage; UIImage *currentMinimumTrackImage; UIImage *currentMaximumTrackImage; 实例方法123456- (void)setThumbImage:(UIImage *)image forState:(UIControlState)state;- (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state;- (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state;- (UIImage *)thumbImage forState:(UIControlState)state;- (UIImage *)minimumTrackImage forState:(UIControlState)state;- (UIImage *)maximumTrackImage forState:(UIControlState)state; UITextField常用属性NSString *text; UIColor *textColor; UIFont *font; NSTextAlignment textAlignment; UITextBorderStyle borderStyle; NSString *placeholder; BOOL clearOnBeginEditing; BOOL adjustsFontSizeToFitWidth; CGFloat minimumFontSize; id delegate; UIImage *background; UIImage *disabledBackground; BOOL editing; UITextFieldViewMode clearButtonMode; UIView *leftView; UITextFieldViewMode leftViewMode; UIView *rightView; UITextFieldViewMode rightViewMode; UIView *inputView; UIView *inputAccessoryView; 实例方法12- (void)drawPlaceholderInRect:(CGRect)rect;- (void)drawTextInRect:(CGRect)rect; UISegmentedControl常用属性UISegmentedControlStyle segmentedControlStyle; NSUInteger numberOfSegments; &lt;readonly&gt; UIColor *tintColor; NSInteger selectedSegmentIndex; 实例方法123456789101112131415- (id)initWithItems:(NSArray *)items;- (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated;- (void)insertSegmentWithImage:(UIImage *)image atIndex:(NSUInteger)segment animated:(BOOL)animated;- (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated;- (void)removeAllSegments;- (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment;- (NSString *)titleForSegmentAtIndex:(NSUInteger)segment;- (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment;- (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment;- (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;- (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment;- (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment;- (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment;- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics;- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics; UIPageControl常用属性NSInteger numberOfPages; NSInteger currentPage; BOOL hidesForSinglePage; BOOL defersCurrentPageDisplay; //点击翻页无效 UIColor *pageIndicatorTintColor; UIColor *currentPageIndicatorColor; 实例方法12- (void)updateCurrentPageDisplay;- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; UISwitch常用属性UIColor *onTintColor; UIColor *tintColor; UIColor *thumbColor; UIImage *onImage; UIImage *offImage; BOOL on; 实例方法12- (void)initWithFrame:(CGRect)frame;- (void)setOn:(BOOL)on animated:(BOOL)animated; UIDatePicker常用属性UIDatePicker datePickerMode; NSLocale *locale; NSTimeZone *timeZone; NSDate *date; NSDate *minimumDate; NSDate *MaximumDate; NSTimerInterval *countDownDuration; NSInteger minuteInterval; 实例方法1- (void)setDate:(NSDate *)date animated:(BOOL)animated; UILabel常用属性NSString *text; UIFont *font; UIColor *color; UIColor *shadowColor; CGSize shadowOffset; NSTextAlignment textAlignment; NSLineBreakMode lineBreakMode; NSAttributedString attributedText; UIColor *highlightedTextColor; BOOL highlighted; BOOL userInteractionEnabled; BOOL enabled; NSInteger numberOfLines; BOOL adjustsFontSizeToFitWidth; BOOL minimumFontSize; 实例方法12- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines;- (void)drawTextInRect:(CGRect)rect; UIAlertView常见属性id delegate; NSString *title; NSString *message; NSInteger cancelButtonIndex; readonly NSInteger numberOfButtons； NSInteger firstOtherButtonIndex; BOOL visible; UIAlertViewStyle alertViewStyle; 实例方法1234- (id)initWithTitle:(NSString *)title message:(NSString *)message delegate:(id /*&lt;UIAlertViewDelegate&gt;*/)delegate cancelButtonTitle:(NSString *)cancelButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;- (void)show;- (void)dismissWithClickEdButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;- (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex; UIActionSheet常见属性id delegate; NSString *title; UIActionSheetStyle actionSheetStyle; NSInteger cancelButtonIndex; NSInteger destructiveButtonIndex; readonly NSInteger numberOfButtons; NSInteger firstOtherButtonIndex; BOOL visible; 实例方法123456789- (id)initWithTitle:(NSString *)title delegate:(id&lt;UIActionSheetDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle destructiveButtonTitle:(NSString *)destructiveButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;- (NSInteger)addButtonWithTitle:(NSString *)title;- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;- (void)showFromToolbar:(UIToolBar *)view;- (void)showFromTabBar:(UITabBar *)view;- (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animates;- (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;- (void)showInView:(UIView *)view;- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; UIImageView常用属性UIImage *image; UIImage *highlightedImage; BOOL userInteractionEnable; BOOL highlighted; NSArray *animationImages; NSArray *highlightedAnimationImages; NSTimeInterval animationDuration; NSInteger animationRepeatCount; UIColor tintColor; 实例方法12345- (id)initWithImage:(UIImage *)image;- (id)initWithImage:(UIImage *)image highlightedImage:(UIImage *)highlightedImage;- (void)startAnimating;- (void)stopAnimating;- (BOOL)isAnimating; UINavigationBar常用属性UIBarStyle barStyle; id delegate; BOOL translucent; NSArray *items; UIColor *tintColor; UIColor *barTintColor; UIImage *shadowImage; NSDictionary *titleTextAttributes; UIImage *backIndicatorImage; UIImage *backIndicatorTransitionMaskImage; readonly UINavigationItem *topItem; UINavigationItem *backItem; 实例方法123456789- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;- (UINavigationItem *)popNavigationItemAnimated:(BOOL)animated;- (void)setItems:(NSArray *)items animated:(BOOL)animated;- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;- (void)setBackgroundImage:(UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0);- (UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics;- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics;- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics; UITabBar常用属性id delegate; NSArray *items; UIBarStyle barStyle UITabBarItem *selectedItem; UIColor *tintColor; UIColor *barTintColor; BOOL translucent; UIColor *selectedImageTintColor; UIImage *backgroundImage; UIImage *selectionIndicatorImage; UIImage *shadowImage; UITabBarItemPositioning itemPositioning; CGFloat itemWidth; CGFloat itemSpacing; 实例方法1234- (void)setItems:(NSArray *)items animated:(BOOL)animated;- (void)beginCustomizingItems:(NSArray *)items;- (BOOL)endCustomizingAnimated:(BOOL)animated;- (BOOL)isCustomizing; UIToolbar常用属性UIBarStyle barStyle; NSArray *items; BOOL translucent; UIColor *tintColor; UIColor *barTintColor; id delegate; 实例方法12345- (void)setItems:(NSArray *)items animated:(BOOL)animated;- (void)setBackgroundImage:(UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (void)setShadowImage:(UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom;- (UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom; UISearchBar常用属性UIBarStyle barStyle; id delegate; NSString *text; NSString *prompt; NSString *placeholder; BOOL showsBookmarkButton; BOOL showsCancelButton; BOOL showsSearchResultsButton; UIColor *tintColor; UIColor *barTintColor; UISearchBarStyle searchBarStyle; UITextAutocapitalizationType autocapitalizationType; UITextAutocorrectionType autocorrectionType; UITextSpellCheckingType spellCheckingType; UIKeyboardType keyboardType; NSArray *scopeButtonTitles; NSInteger selectedScopeButtonIndex; BOOL showsScopeBar; UIView *inputAccessoryView; UIWebView常用属性id delegate; readonly BOOL canGoBack; BOOL canGoForward; BOOL loading; UIScrollView *scrollView; NSURLRequest *request; 实例方法12345678- (void)loadRequest:(NSURLRequest *)request;- (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL;- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;- (void)reload;- (void)stopLoading;- (void)goBack;- (void)goForward;- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; UIPickerView常用属性id dataSource; id delegate; BOOL showsSelectionIndicator; NSInteger numberOfComponents;&lt;readonly&gt; 实例方法1234567- (NSInteger)numberOfRowsInComponent:(NSInteger)component;- (CGSize)rowSizeForComponent:(NSInteger)component;- (UIView *)viewForRow:(NSInteger)row forComponent:(NSInteger)component;- (void)reloadAllComponents;- (void)reloadComponent:(NSInteger)component;- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated;- (NSInteger)selectedRowInComponent:(NSInteger)component; UITableViewCell常用属性UITableViewStyle style; &lt;readonly&gt; id dataSource; id delegate; CGFloat rowHeight; CGFloat sectionHeaderHeight; CGFloat sectionFooterHeight; CGFloat estimatedRowHeight; CGFloat estimatedSectionHeaderHeight; CGFloat estimatedSectionFooterHeight; UIEdgeInsets separatorInset; UIView *backgroundView; BOOL editing; BOOL allowsSelection; BOOL allowsSelectionDuringEditing; BOOL allowsMultipleSelection; BOOL allowsMultipleSelectionDuringEditing; UIView *tableHeaderView; UIView *tableFooterView; NSInteger sectionIndexMinimumDisplayRowCount; UIColor *sectionIndexColor; UIColor *sectionIndexBackgroundColor; UIColor *sectionIndexTrackingBackgroundColor; UITableViewCellSeparatorStyle separatorStyle; UIColor *separatorColor; 实例方法123456789101112131415161718192021222324252627282930313233343536- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;- (void)reloadData; - (void)reloadSectionIndexTitles;- (NSInteger)numberOfSections;- (NSInteger)numberOfRowsInSection:(NSInteger)section;- (CGRect)rectForSection:(NSInteger)section;- (CGRect)rectForHeaderInSection:(NSInteger)section;- (CGRect)rectForFooterInSection:(NSInteger)section;- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;- (NSArray *)indexPathsForRowsInRect:(CGRect)rect; - (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; - (NSArray *)visibleCells;- (NSArray *)indexPathsForVisibleRows;- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;- (void)beginUpdates;- (void)endUpdates;- \u0005(void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;- (NSIndexPath *)indexPathForSelectedRow;- (NSArray *)indexPathsForSelectedRows;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier;- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier;- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier; UIViewController常用属性UIView *view; NSString *title; readonly NSString *nibName; NSBundle *nibBundle; UIStoryboard *storyboard; UIViewController *parentViewController; UIViewController *presentedViewController; UIViewController *presentingViewController 实例方法1- (void)loadView; UIViewController的常见子类UITabBarController常用属性NSArray *viewControllers; UIViewController *selectedViewController; NSUInteger selectedIndex; id delegate; readonly UITabBar *tabBar; UINavigationController *moreNavigationController; 实例方法1- (void)setViewControllers:(NSArray *)viewControllers animated:(BOOL)animated; UINavigationController常用属性id delegate; NSArray *viewControllers; BOOL toolbarHidden; readonly UIViewController *topViewController; UIViewController *visibleViewController; UINavigationBar *navigationBar; UIToolbar toolbar; 实例方法12345678- (id)initWithRootViewController:(UIViewController *)rootViewController;- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;- (UIViewController *)popViewControllerAnimated:(BOOL)animated;- (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;- (NSArray *)popToRootViewControllerAnimated:(BOOL)animated;- (void)setViewControllers:(NSArray *)viewControllers animated:(BOOL)animated;- (void)setNavigationBarHidden:(BOOL)hidden animated:(BOOL)animated;- (void)setToolbarHidden:(BOOL)hidden animated:(BOOL)animated; UITableViewController常用属性UITableView *tableView; BOOL clearsSelectionOnViewWillAppear; UIRefreshControl *refreshControl; 实例方法1- (id)initWithStyle:(UITableViewStyle)style; UIBarItem常用属性BOOL enable; NSString *title; UIImage *image; UIImage *landscapeImagePhone; UIEdgeInsets imageInsets; UIEdgeInsets landscapeImagePhoneInsets; NSInteger tag; 实例方法12- (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;- (NSDictionary *)titleTextAttributesForState:(UIControlState)state; UIBarButtonItem常用属性UIBarButtonItem style; CGFloat width; NSSet *possibleTitles; UIView *customView; SEL action; id target; 实例方法1234567- (id)initWithImage:(UIImage *)image style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;- (id)initWithImage:(UIImage *)image landscapeImagePhone:(UIImage *)landscapeImagePhone style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;- (id)initWithTitle:(NSString *)title style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;- (id)initWithBarButtonSystemItem:(UIBarButtonSystemItem)systemItem target:(id)target action:(SEL)action;- (id)initWithCustomView:(UIView *)customView;- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics;- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics UITabBarItem常用属性UIImage selectedImage; NSString badgeValue; 实例方法123- (id)initWithTitle:(NSString *)title image:(UIImage *)image tag:(NSInteger)tag;- (instancetype)initWithTitle:(NSString *)title image:(UIImage *)image selectedImage:(UIImage *)selectedImage NS_AVAILABLE_IOS(7_0);- (id)initWithTabBarSystemItem:(UITabBarSystemItem)systemItem tag:(NSInteger)tag; UINavigationItem常用属性NSSting *title; UIBarButtonItem *backBarButtonItem; UIView *titleView; NSString *prompt; BOOL hidesBackButton; NSArray *leftBarButtonItems; NSArray *rightBarButtonItems; BOOL leftItemsSupplementBackButton; UIBarButtonItem *leftBarButtonItem; UIBarButtonItem *rightBarButtonItem; 实例方法123456- (id)initWithTitle:(NSString *)title;- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated;- (void)setLeftBarButtonItems:(NSArray *)items animated:(BOOL)animated; - (void)setRightBarButtonItems:(NSArray *)items animated:(BOOL)animated;- (void)setLeftBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;- (void)setRightBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated；","tags":[{"name":"UI_Notes","slug":"UI-Notes","permalink":"https://github.com/xiao-xi/tags/UI-Notes/"}]},{"title":"UINavigationController","date":"2014-11-05T09:56:21.000Z","path":"2014/11/05/UINavigationController/","text":"###自定义导航控制器 导航控制器导航栏 UINavigation Bar 导航控制器工具栏 UInavigation ToolBar 注意: 一个UINavigationController只有一个UINavigetionBar UINavigationBar上只有一个UIBarButtonItem UIBarButtonItem的显示由UIViewController控制 ##UIBarButtonItem UIBarButtonItem对象实际上是一个button，主要放在ToolBar和UINavigationBar对象上 // 根据内置的系统风格UIBarButtonItem初始化对象 -(id)initWithBarButtonSystemItem:(UIBarButtonSystemItem)systemItem target:(id)target action:(SEL)action; // 初始化一个带图片的UIBarButtonItem对象 -(id)initWithImage:(UIImage *)image style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action; // 初始化一个带图片的UIBarButtonItem对象，包括iPhone的竖屏和横屏 -(id)initWithImage:(UIImage )image landscapeImagePhone:(UIImage )landscapeImagePhone style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action NS_AVAILABLE_IOS(5_0); //初始化一个自定义的UIBarButtonItem对象 -(id)initWithCustomView:(UIView *)customView; ###导航栏风格 (UINavigationBar) self.navigationController.navigationBar.barStyle = UIBarStyleBack; self.navigationController.navigationBar.transluent = YES;(透明) self.navigationController.navigationBar.tintColor = [UIColor redColor];(设置导航栏自带的back 等颜色) self.navigationController.navigationBar.tintColor = [UIColor colorWithRed:120/255.0 green:200/255.0 blue:75/255.0 alpha:1];（使用三原色的初始化方法来来获取UIcolor的颜色值） [UIColor colorWithPatternImage:[UIImageNamed:@”img”]];(以图片作为颜色) [self.navigationItem setHidesBackButton:YES];(隐藏返回按钮) self.navigationItem.prompt = @””;(设置导航栏提示用户内容，位置在导航栏的上方 30px)(若设置为nil则取消提示) ###导航控制器工具栏（UINavigation ToolBar） 一个UINavigationController只有一个UINavigation ToolBar对象，默认情况下，这个ToolBar是隐藏的 // 显示导航控制器上的ToolBar [self.navigationController setToolbarHidden:NO animated:YES]; UINavigation ToolBar上放置的元素也是UIBarButtonItem //初始化UIToolBar的UIBarButtonItem 实例，与UINavigation 中左右栏目是相同的 -(id)initWithBarButtonSystemItem:(UIBarButtonSystemItem)target:(id) action:(SEL) //使用NSArray 向UIToolBar添加对象 [self setToolbarItems:(NSArray *)array animated:YES]; 系统设置UIToolBar的间隔UIBarButtonSystemItemFlexibleSpace 自定义item之间的列宽，通过 .width属性设置UIBarButtonSystemItemFixedSpace","tags":[{"name":"UINavigationController","slug":"UINavigationController","permalink":"https://github.com/xiao-xi/tags/UINavigationController/"}]},{"title":"Block(代码块)","date":"2014-10-24T13:36:17.000Z","path":"2014/10/24/Block-代码块/","text":"##概述 - 代码块对象简称为“代码块”，是对C语言中函数的扩展。运行在iOS4。0和OS X10.6版本以上 - 代码块实际上是由C语言实现的，所以在各种以C作为基础的语言内都是有效的包括：Objective－C，C＋＋以及Objective－C++ - 代码块本质上是和其他变量类似，不同的是，代码块存储的数据是一个函数体，使用代码块时，可以像调用其他标准函数一样，传入参数数，并得到返回值。 - 代码块不属于ANSI的C语言标准。关于代码块的提议已经提交给了C程序语言标准团体。 ##函数指针 VS 代码块函数指针的语法格式 返回值类型（*函数名）（参数列表）； eg: void (*myFunction) (void); 代码块的语法格式 返回值类型（^代码块名）(参数列表) ＝ ^返回值类型(参数列表){表达式；}； eg: void (^myBlock)() = ^{printf(&quot;Hello, Block\\n&quot;);}; 说明： 返回值类型和参数列表都可以有条件省略 省略返回值类型，若表达式中有return语句就使用该返回值的类型，若没有，则为void 省略返回值类型时，若表达式中有多个return语句，则所有return语句返回值类型必须相同 如果不使用参数，则参数列表也可以省略 ##代码块的使用 直接使用 void(^myBlock)() = ^{printf(&quot;Hello,Block\\n&quot;);}; myBlock(); 代码块内联 ￼NSArray *array = @[@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;, @&quot;Four&quot;]; ￼NSLog(@&quot;Unsorted array: %@&quot;, array); ￼NSArray *sortedArray = [array ￼sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {return [obj1 compare:obj2]; ￼}]; NSLog(@&quot;Sorted array: %@&quot;, sortedArray); ##使用typedef定义相同类型的代码块 typedef NSComparisonResult(^NSComparator)(id obj1,id obj2); ##代码块的变量 全局变量和静态变量在代码块内部可以正常使用(可以修改其值) 局部变量在代码块内部无法修改其值,原因是代码块的局部变量在编译阶段被看做为常量 如果需要在代码块中修改局部变量,需要在局部变量前面加__block修饰符","tags":[{"name":"Block","slug":"Block","permalink":"https://github.com/xiao-xi/tags/Block/"}]},{"title":"KVC-NSKeyValueCoding非正式协议","date":"2014-10-24T12:54:54.000Z","path":"2014/10/24/KVC-NSKeyValueCoding非正式协议/","text":"#什么是KVC —&gt;What KVC指的就是NSKeyValueCoding非正式协议。 KVC是一种间接地访问对象的属性的机制。 这种间接表现在通过字符串来标识属性,而不是通过调用存取方法或直接地访问实例变量的方式,即不依赖域setter和getter方法。 KVC机制不仅支持对象,还支持标量和结构体类型,这些非对象的类型会被自动的装箱和开箱。 ##Key &amp; Key Path 键(Key)是一个字符串用来标识对象里面的一个指定的属性。一般一个键对应对象的存取方法或 实例变量。键必须是ASCII码,一般以小写字母开始,不能包含空格。 A key path is a string of dot separated keys that is used to specify a sequence of object properties to traverse. The property of the first key in the sequence is relative to the receiver, and each subsequent key is evaluated relative to the value of the previous property. 键路径(Key Path)是一个由点进行分割的一系列键组成的字符串 #KVC的使用 -(void)setValue:(id)value forKey:(NSString *)key -(id)valueForKey:(NSString *)key KVC的调用机制： setValue:forKey: 的机制跟valueForKey想死。它首先查找参数名命名的setter方法，如果找到的话则完成设置；如果没有找到setter方法，则直接在类中找到格式为_key或者key的实例变量，然后将value赋值给它。 valueForKey: 会首先查找以参数命名（格式为_key或者isKey）的getter方法，如果找到的话则调用这个方法；如果没有找到这样的getter方法，它将会在对象内部寻找名称格式为_key或者key的实例变量，然后返回。 ｀ ￼￼-(void)setValue:(id)value forKeyPath:(NSString *)keyPath -(id)valueForKeyPath:(NSString *)keyPath 注意： 键路径的深度是任意的，具体取决于对象之间的关系的复杂度。 ｀ -(void)setValue:(id)value forUndefinedKey:(NSString *)key ￼-(id)valueForUndefinedKey:(NSString *)key 处理未定义的键 ｀ -(void)setNilValueForKey:(NSString *)key 设置nil ｀ ￼KVC与点语法是正交的,也就是一点关系都没有 The accessor patterns are written in the form -set&lt;Key&gt;: or -&lt;key&gt;","tags":[{"name":"KVC","slug":"KVC","permalink":"https://github.com/xiao-xi/tags/KVC/"}]},{"title":"Foudation","date":"2014-10-23T13:20:00.000Z","path":"2014/10/23/Foudation/","text":"Foundation是UIKit和AppKit这两类UI框架的基础 因为它不包含UI对象,所以,其对象可以在iOS和Mac OS X应用中兼容 Foundation框架是以另一框架CoreFoundation为基础创建的 ##Foudation对象主要分类 值对象 集合 操作系统服务 包括三个方面: `文件系统、URL、进程间通讯` 。 通知 归档和序列化 表达式和条件判断 Objective-C语言服务 ##一些有用的数据类型 范围(NSRange) typedef struct _NSRange { NSUInteger location; NSUinteger length; } NSRange; 创建NSRange的三种方式: 1. 直接给字段赋值 NSRange range; range.location = 17; range.length = 4; 2. C语言的聚合结构赋值机制(花括号) NSRange range = {17, 4}; 3. cocoa提供的NSMakeRange()函数 NSRange range = NSMakeRange(17, 4); 几何数据类型 (这个属于CoreGraphics框架) CGPoint CGSize CGRect ##Foundation的一些常用类 字符串 NSString 创建字符串: NSString *str = @&quot;Hello,world&quot;; NSString *height = [NSString stringWithFormat:@&quot;Your height is %dfeet, %d inches&quot;, 5, 11]; 实例方法: 字符串长度: - (NSUInteger) length; 字符串比较: - (BOOL) isEqualToString:(NSString *)aString; - (NSComparisonResult)compare:(NSString *)string; - (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask; 集合大家族 NSArray、NSMutableArray NSEnumerator NSDictionary、NSMutableDictionary 创建字典: 1. + (id) dictionaryWithObjectsAndKeys: (id) firstObject, ...; 2. @{key:value,...}; 访问字典中的对象: 1. - (id) objectForKey: (id) aKey; 2. dict[key]; 创建可变字典: +(id)dictionaryWithCapacity: (NSUInteger) numItems; 添加元素: - (void)setObject:(id)anObject forKey:(id)aKey; 删除元素: - (void)removeObjectForKey: (id) aKey; 其他数值对象 NSNumber 装箱: 创建NSNumber对象(将基本数据类型封装成NSNumber对象) 1. + (NSNumber *) numberWithChar: (char) value; + (NSNumber *) numberWithBool: (BOOL) value; number = @YES; //布尔值 + (NSNumber *) numberWithInt: (int) value; + (NSNumber *) numberWithFloat: (float) value; 2. NSNumber *number; number = @&apos;X&apos;; //字符型 number = @12345; //整型 number = @12345ul; //⽆无符号整型 number = @123.45f; //浮点型 开箱: 从NSNumber对象中取出基本数据类型 Cocoa提供的将常用struct型数据与NSValue互相转换的便捷方法 - (char) charValue; - (int) intValue; - (NSString *)stringValue; - (float) floatValue; - (BOOL) boolValue; NSValue 创建NSValue对象,即装箱 + (NSValue *) valueWithBytes: (const void *)value objType:(const char*)type; 提取NSValue中的数值,即开箱 - (void)getValue:(void *)buffer; Cocoa提供的将常用struct型数据与NSValue互相转换的便捷方法 + (NSValue *)valueWithPoint:(NSPoint)aPoint; - (NSPoint)pointValue; - (NSSize)sizeValue; - (NSRect)rectValue; + (NSValue *)valueWithSize:(NSSize)size; + (NSValue *)valueWithRect:(NSRect)rect; NSNull 创建NSNull对象 + (NSNull *) null;","tags":[{"name":"Foundation Kit","slug":"Foundation-Kit","permalink":"https://github.com/xiao-xi/tags/Foundation-Kit/"}]},{"title":"c-notes","date":"2014-10-23T12:31:16.000Z","path":"2014/10/23/C笔记/","text":"间接 标准 统一 机制 策略iTerm 的配置 将iTerm移到应用程序 进入配置文件 1$ cd iterm$zsh/.oh my zsh/templates ls 查看当前目录下的所有文件 拷贝当前目录下的文件 zshrc.zsh-template 到~/.zshrc 下 1$ cp zshrc.zsh-template 退出iterm，重启即可 1$ q VI编辑器中的基本命令VI编辑器中的基本内部命令在终端使用 vimtutor 命令可以查看VI编辑器中的基本命令 复制命令 复制单个字符: y 复制一个单词: yw 复制所选中的一行: yy 移动命令移动光标到行首: ^ 向前移动一个单词: b 向后移动一个单词: w 向下翻一页: ctrl ＋ f 向上翻一页: ctrl ＋ b d ＋ ^ 删除光标所在位置到行首的所有字符 d ＋ $ 删除光标所在位置到行尾的所有字符 VI编辑器中的基本外部命令 删除命令 * rm ［filename］ 删除基本文件 * rm －r ［filename］ 有提示的删除一个文件夹 * rm －rf ［filename］ 强制删除文件夹，包括文件夹内的所有子文件夹以及自文件，且无提示 * rm \\*~ (*为通配符)，即删除所有以～结尾的文件 拷贝命令 * 若file2文件家不存在，默认将file1 拷贝一分命名为file2 * 若file2时文件夹，默认将file1拷贝到文件夹file2下，且名字仍为file1 * file1 file2 不加路径的情况下，默认是把当前路径下的文件拷贝到当前路径下 * ile1 file2 表示为路径的形式，则是把指定路径下的file1 拷贝到指定路径下命名为file2，或是拷贝到制定路径下的file2文件夹下命名仍然是file1 * cp －r/R ［file1］［file2］ * 将文件夹1拷贝到文件夹2目录下 重命名（移动命令） mv ［file1］［file2］ 若两文件在同一路径下且file2文件家不存在，默认将file1 重命名为file2 若file2时文件夹，默认将file1移动到文件夹file2下，且名字仍为file1 file1 file2 不加路径的情况下，默认是把当前路径下的文件重命名为file2 file1 file2 表示为路径的形式，则是把指定路径下的file1 移动到指定路径下命名为file2，或是移动到指定路径下的file2文件夹下命名仍然是file1 其他命令 ls －a列出当前目录下的所有文件及文件夹，包括隐藏文件（以 “.” 开始的文件或文件夹）其中 . 和 ..两个文件夹表示是当前路径和上级路径 cd 切换路径 du －h ［filename］ 默认为查看当前路径下人类可读的文件的大小，追加filename，则是查看该文件夹下的人类可读的文件的大小 diff ［file1］［file2］比较两个文件内容是否相同，相同的话无显示结果；不同的话，则列出不同之处 file ［file］ 查看该文件的类型（如二进制类型,ASCII,English等） !!调出上次使用的命令! + 使用过的命令的首字母后第一个单词，调出最近使用过包含该字母或单词的命令ctrl ＋ r 搜索使用过的命令ctrl ＋ c 结束当前输入的命令，即不执行当前输入的命令 gcc 执行命令时 加－g 可进行调试 （l 列出函数的源代码，b 设置断点，r 运行程序，n 执行下一步，s 进入函数内部，p ［var］ 打印变量var的值 q 退出程序 ）, 加 －save－temps 保留编译时生成的结果（即 .i, .s, .o 文件生成且被保留下来可供查看） $?(echo $? 在屏幕上显示上次命令执行的结果，若执行成功则返回0，否则返回1；若上次执行是程序且执行成功则返回return 后的返回值) echo $HOME 显示当前的home路径 echo $USER 显示当前的用户名 cat [filename] | head 查看文件的前十行内容注释方法 // 注释一行 注释多行 /*…*/ #if 0 … #else … #endif 注释从 if 0 到else之间的多行，程序在编译，只编译else与endif之间的多行；若果把0换成非零值，则只 头文件的保护 #ifndef ［宏名］ #define ［宏名］ … #endif 在引用头文件时，如果未定义头文件内已定义过的内容，则定义；否则，不再重复定义 变量的作用范围 函数作用域 仅限在一个函数中使用 文件作用域 仅限在一个文件中使用 代码快作用域 受限与“ ｛｝” 的限制 原型作用域 函数声明 变量的大小 char c 语言标准规定为1字节 int 一般为4字节 规定int的大小不超过long的大小，short的大小不超过int的大小 指针的大小与long的大小等于机器字长（即 32位os 其大小为4字节，64的os其大小为8字节），古可用sizeof(int)测试机器os时多少位的（sizeof只是一个操作符，并不是一个函数）。 数据类型 整型：char short int long 浮点型： float double 指针 聚合类型：数组，结构体，枚举类型 派生类型：字符串，联合体赋值操作 值得注意点 数组名是个地址，只能在初始化是对其赋值，在以后使用中，数组名是个地址常量，不能被作为左值对其赋值 对字符数组初始化赋值为字符串字面常量，相当于把全局数据段的字符串复制到栈对字符数组分配的地址中去。 指针是指针变量可以对其进行赋值运算 结构体类型的变量可以作为左值对其进行赋值 分配内存问题 在函数中定义变量，对其分配内存时不能太大 可使用全局变量在全局数据段分配大内存 可使用malloc（size）动态在堆中分配大内存，使用memset将申请的内存初始化。 字符串操作中段错误 定义一个指向NULL地址的字符串指针 NULL的ascii值为0，地址为0的内存不可以被访问，故对该地址进行写操作是没有权限的。 在定义一个字符串数组时对其进行初始化为字符串字面常量 对字符串数组定义并初始化为一个字符串字面常量时，字符数组首地址指向的是全局数据段的地址，对该段内存进行写操作是没有全县的。 使用strcpy，strcat，strcmp，strcasecmp等字符串操作函数，将目标字符串读／写爆。应该使用strncpy，strncat，strncmp，strncasecmp等字符串操作函数防止读写越界。 文件操作常用函数 字符读写 fgetc(FILE *fp); 1fputc(int c,FILE*fp); 按行读写 fgets(char str,size,FILE \\fp); 1fputs(char \\*,size,FILE *fp); 数据块读写 fread(char *,size,number,FILE *fp); 1fwrite(char \\*, size,number,FILE \\*fp); 格式化读写 fprintf(FILE *fp,format,…); 1fsanf(FILE *fp,format,...); 三种缓冲机制 行缓冲 缓冲区存储一行信息才进行输出 eg：stdout（标准输出） 全缓冲 缓冲区存储满信息才进行输出 无缓冲 缓冲区只要有信息存储进去就进行输出 eg：stderr（报错）改变文件指针位置 rewind(FILE *fp); 改变指针指向头文件 fseek(FILE *fp,int length,long where);(where 可取值为SEEK_SET SEEK_CUR SEEK_END) 改变指针位置从（文件头部，当前位置，文件尾部）移动length个字节的位置","tags":[{"name":"c","slug":"c","permalink":"https://github.com/xiao-xi/tags/c/"}]},{"title":"","date":"2014-10-23T05:17:08.000Z","path":"2014/10/23/OC笔记/","text":"##NSLog 与 printf的不同 1. NSLog接收oc字符串作为参数，printf接收c语言的字符串作为参数 2. NSLog输出后会自动换行，printf在输出后不会自动换行 3. 使用NSLog时，需要包含头文件#import &lt;Foundition/Foundition.h&gt;；而使用printf时，需要包含头文件#include&lt;stdio.h&gt; 4. NSLog可以输出日期，时间戳，进程号等信息，而printf不能输出这些信息 常用术语面向过程 ： Procedure Oriented 面向对象 ： Object Oriented ，简称OO 面向对象编程 ： Object Oriented Programming，简称OOP OC 语法 类的声明 @interface 类名：父类（默认为 NSObject 该类时根类） { 定义成员变量；（默认情况下，成员变量为protect类型，） } （ 可以用@public将其定义为public类型，此时定义的属性或变量允许被外界访问） @property(nonatomic/atomic,readonly/readwrite,assign/strong/retain/wake)类型 属性名；（定义属性可以自动生成setter和getter方法） 声明类方法；（标识 ＋ 该方法向类发消息） 声明实例方法； （标识 － 该方法向对象发消息） 声明类方法时 返回值最好定义为`instancetype`类型 @end 类的实现 @implemention 类名 － 实例方法 ｛ 实现代码； ｝ ＋ 类fangfa ｛ 实现代码； ｝ 重写父类方法； 如：descripition、 dealloc、init等 @end 3.创建对象 1.包含所创建类的头文件 2.类名 ＊对象名； 2.1 类名 ＊对象名 ＝ ［［类名 alloc］init］；（创建对象并为其分配内存、初始化） 2.2 类名 ＊对象名 ＝ ［类名 new］；（每次都会创建出新的对象，并且返回对象的地址。） 3. 给对象赋值；（可以调用相应的类方法）； 4. 给对象发消息，完成所需要进行的操作；［对象 方法］； 匿名对象 方法调用： ［［类名 new］方法］；／［［［类名 alloc］init］方法］； 属性访问： ［类名 new］-&gt;属性 ＝ 赋值；（外界访问定义为public类型的属性） OC方法和函数的区别1. OC方法的声明只能在@interface 和 @end之间，只能在@implementation 和 @end之间。即OC方法独立于类存在。 2. C函数不属于类，跟类没有联系，C函数所有权只属于定义函数的文件 3. C函数不能访问OC对象的成员变量。 OC语法细节1. 成员变量不能在｛｝中进行初始化、不能直接拿去访问 2. 方法的声明不能写在@end之后 3. 方法不能当作函数一样调用 4. 成员变量、方法不能用static等关键字进行修饰 OC方法注意点方法只有声明，没有实现（经典错误，系统提示警告） 方法没有声明，只有实现（编译器警告，但是可以调用，OC的弱语法） 编译的时候，访问没有定义的成员变量直接报错，调用没有的方法，只是警告 没有@interface，纸偶@implemenation也可以成功定义一个类 @implemenation Dog : NSObject { int _age; NSString *_name; } - (void)print { NSLog(@&quot;The dog&apos;s name is %@,ang de it&apos;s %d years old!&quot;,_name,_age); } @end @implemenation 中不能声明和@interface一样的成员变量 OC中有`BOOL`基本数据类型，其值是`YES`和`NO`，而不是true 和false，它实际上是一种对带符号的自负类型（signed char）的定义（typedef），它使用8为存储空间。`YES定义为1，NO定义为0`； 类方法he实例方法 类方法 ＊ 该方法是直接可以用类名来执行的方法（类本身会在内存中占据存储空间，里面有类／对象方法列表） ＊ 以加号 ＋ 开头 ＊ 只能用类名调用，对象不能调用 ＊ 类方法不能访问实例变量（成员变量） ＊ 使用场合：当不需要访问成员变量时，尽量使用类方法 ＊ 类方法和对象方法可以同名 实例方法 ＊ 该方法是用对象名来执行的方法 ＊ 以减号 — 开头 ＊ 只能用对象名调用，类不能调用，该方法没有对象是不能被执行的 ＊ 对象方法能访问实例变量（成员变量） setter和getter方法 setter和getter方法的使用场合 @public的成员可以随意被赋植，应该使用set和get方法来管理成员变量的访问 setter方法 作用：用来设置成员变量，可以在方法里面过滤一些不合理的值 命名规范：方法以set开头，而且后面跟上成员变量名，成员变量名必须首字母大写，尽量形参名称不要与成员变量名重名（成员变量名最好以下划线 _ 开头） 返回值：一般为void getter方法 作用：返回对象内部的成员变量 命名规范：方法名和成员变量名同名 返回值：一般与成员变量的类型相同 self关键字 成员变量和局部变量同名 当成员变量和局部变量同名时，采取就近原则，访问的是局部变量 当self访问成员变量，区分同名的局部变量 使用细节 1. 出现的地方：所有的OC方法中（对象方法／类方法），不能出现在函数 2. 作用： 使用“self.属性”访问当前方法中的成员变量 使用“self-&gt; 成员变量”访问当前方法中public成员变量 使用“［self 方法］”调用方法（类方法／实例方法） 3. 类方法中self只能调用类方法，实例方法中self只能调用实例方法 继承 继承的概念 1. is－a机制 2. 即当创建的多个类有共同的属性和行为时，可以抽出一个类作为父类，在父类中定义相同的属性，声明实现相同的行为（方法）； 3. 子类可以使用父类的所有属性和方法，并且子类可以在父类的基础上拓补自己的属性和方法，包括重写父类方法。重写父类方法时，子类对象会优先调用子类重写后的方法。 4. 子类属性和方法访问的过程： 如果子类没有相应的方法或属性，则去访问父类，一次递进知道找到NSObject根类，如果仍然没有找到相对应的方法和属性，则报错。 继承的专业术语 父类／超类 superclass 子类 subclass／subclasses 继承的细节 单继承，不支持多继承 子类和父类不能有相同的成员变量 子类可以重写父类中声明的方法（在代码运行时，oc确保调用相应类的重写方的实现） 继承的优缺点 优点： 在不改变原来模型的基础上，拓充方法 建立了类与类的联系 抽取了公共代码 缺点： 耦合性强 super关键字 super既不是参数，也不是实例变量，而是oc编译器提供的功能 用于提供一种在子类中显示调用父类的方法 继承的局限性 父类不能访问子类属性、调用子类方法 不能继承累簇（如 NSString累簇） 多态 多态的基本概念 某一类事物的多种形态 OC对象具有多态性 多态的体现 主要体现在继承下：向不同的对象发相同的消息，其呈现的行为不一样。（如DrawShape程序中，向不同图像的对象发送draw消息，其打印结果是不同的）。 子类对象可以赋值给父类指针； 如：Father *f = [children new]; 父类指针可以访问对应的属性和方法 如： f.age = 23; [f study]; 多态的好处 用父类接收参数，节省代码 多态的局限性 不能访问子类的属性（可以考虑强制转换） 多态的细节 动态绑定，在运行时根据对象的类型确定动态调用的方法 复合 复合包括组合和聚合 has－a机制 组合和聚合表示将各个部分组合在一起，用于表达整体与部分的关系。在面向对象的编程思想里，就是用已有类的对象封装新的类。 组合 ：表示一种强的、严格的整体与部分的关系，部分和整体的生命周期一样。 比如：人和人头 聚合 ：表示一种弱的整体与部分的关系，比如： 汽车和轮胎 Foundition框架1. OC集合只能存储OC对象，不能存储c语言中的基本数据类型，如int，float，enum，struct，且不能在集合中存储nil。 字符串 不可变字符串 ： NSString *string1; 可变字符串 ： NSMutableString *string2; 对可变字符串的操作： 2.1 增加元素 string2 appendFormat:@&quot;hello&quot;]; 2.2 删除元素 [string2 replaceCharacterInRange:NAMakeRange(2,3)]; 2.3 修改元素（替换） [string2 replaceCharacterInRange:NAMakeRange(2,3)withString:@&quot;word&quot;]; 字符串的操作 3.1 比较 //判断两个字符串是否相等，返回的是BOOL值 [str1 isEqualTo:str2]; NSCompareResult res = [str1 copmare:str2]; 不区分大小写的比较：caseInsensitiveCompare 有选择参数的比较： ［str compare：str2 option：NSStringCompareOption］ NSStringCompareOption选项可以传入的参数 enum { NSCaseInsensitiveSearch = 1, 不区分大小写 NSLiteralSearch = 2, 对于相等的字符串逐个比较 NSBackwardsSearch = 4, 从后向前比较 NSAnchoredSearch = 8, 限制比较从开始还是结尾 NSNumericSearch = 64, 对于数字按数字比较 NSDiacriticInsensitiveSearch = 128, 不区分音节 NSWidthInsensitiveSearch = 256, 忽略full－width half－width （如 Unicode code point U+FF41 和 Unicode code point U+0061 的字母 “a”is equal） NSForcedOrderingSearch = 512, 对于不区分大小写比较相等的字符串，强制返回NSOderedAscending or NSOrderedDeascending （如“aa” is grater than “AA”） NSRegularExpressionSearch = 1024 treated as an ICU－compatible regular expression }; NSCompareResult 有三种值： NSOrderedSame 两字符串相等 NSOrderedAscending str1 &lt; str2 NSOrderedDeascending str1 &gt; str2; 3.2 求长度 NSUInteger strlen = [str1 length]; 3.3 大小写转换 str2 = [str1 uupercaseString]; str2 = [str1 lowercaseString]; 3.4 获取文件前缀、后缀 str2 ＝[str1 hasPrefix:@&quot;word&quot;]; str2 = [str1 hasSuffix:@&quot;txt&quot;]; 3.5 获取子串 //获取str2在str1中的位置，即range.location and range.length range = [str1 rangOfString:str3]; range = [str1 rangOfString:@&quot;hello&quot;]; //获取str1 第6个位置之后的字符串赋值给str2 str2 = [str1 substringFromIndex:6]; //获取str1 从开始到第6个位置之间的字符串赋值给str2 str2 = [str1 substringTOIndex:6]; //获取str1 从第6个位置开始长度为5的字符串赋值给str2 str2 = [str1 substringWithRange:NSMakeRange（6，7）]; 3.6 文件路径的转换 //间文件路径字符串str1 ＝ @“~/test.html”的路径转换为绝对路径赋值给str2 str2 = [str1 stringByExpandingTildeInPath]; //间文件路径字符串str1 ＝ @“/users/qingyun/test.html”的路径转换为相对路径赋值给str2 str2 = [str1 stringByAbbreviatingWithTildeInPath]; 3.7 文件路径的扩展名 str2 = [str1 pathExtension]; 此时 str2 ＝ @“html”； 3.7 删除文件路径的后缀 str2 = [str1 stringByDeletePathExtension]; 此时 str2 ＝ @“~/test”； 3.9 追加字符串 str1 ＝ @”hello word”; str2 = [str1 stringByAppendingFormat:@&quot;wellcom&quot;]; 此时 str2 ＝ @“hello word wellcom”; 数组 不可变数组 ： NSArray *array1; 可变数组 ： NSMutableArray *array2; 数组初始化： NSArray *array1 = [NSArray arrayWithObjects:@&quot;hello&quot;,@&quot;word&quot;,@&quot;two&quot;,nil]; NSArray *array1 = @[@12,@34,@&quot;hello&quot;,@&quot;error&quot;]; //创建空数组 NSMutableArray *array2 = [NSMutableArray array]; //用已有的数组创建新数组 NSMutableArray *array2 = [NSMutableArray arrayWithArray:array]; //创建一个数组，并预分配内存 NSMutableArray *array2 = [NSMutableArray arrayWithCapacity:40]; 对可变数组的操作： 2.1 增加元素 [array2 addObjects:@&quot;hello&quot;]; 2.2 删除元素 //删除下标为2的对象 [array2 removeObjectsAtIndex:2]; //删除一定范围内的所有@“hello” [array2 removeObject:@&quot;hello&quot; inRange:NSMakeRange(2, 3)]; [array3 removeObjectIdenticalTo:@&quot;is&quot; inRange:NSMakeRange(1, 5)]; //删除该数组内的所有@“hello” [array2 removeObjectIdenticalTo:@&quot;hello&quot;]; 2.3 修改元素（替换） [array2 removeObjectsAtIndex:2 withObject:@&quot;dog&quot;]; [array2 removeObjectsAtIndex:2 withObject:str]; [array2 removeObjectsInRange:NSMakeRang(0,2) withObjectFromArray:array]; 2.4 插入元素 [array2 insertObjects:str1 AtIndex:2]; 2.5 访问数组某个对象 array2［下标］ 字典 不可变数组 ： NSDictionary *dictionary1; 可变数组 ： NSMutableDictionary *dictionary2; 字典初始化： Dictionary *dictionary1 = [NSDictionary dictionaryWithObjectsAndKeys:str1,@&quot;hello&quot;,str2,@&quot;word&quot;,str3,@&quot;two&quot;,nil]; Dictionary *dictionary1 = @{@&quot;num1&quot;:@12,@&quot;num2&quot;:@34,@&quot;str1&quot;:@&quot;hello&quot;,@&quot;str2&quot;:@&quot;error&quot;}; //创建空字典 NSMutableDictionary *dictionary2 = [NSMutableDictionary dictionary]; //用已有的字典创建新字典 NSMutableDictionary *dictionary2 = [NSMutableDictionary dictionaryWithDictionary:array]; //创建一个字典，并预分配内存 NSMutableDictionary *dictionary2 = [NSMutableDictionary dictionaryWithCapacity:40]; 对可变字典的操作： 2.1 增加元素 [dictionary2 addObjects:(id)forKey:@&quot;key&quot;]; 2.2 删除元素 [dictionary2 removeObjectForKey:@&quot;key&quot;]; 2.3 修改元素（替换） [dictionary2 setObject:（id）forKey:@&quot;key&quot;]; 2.4 访问字典 dictionary2［@“key”］; [dictionary2 objectForKey:@&quot;key&quot;] 装箱－开箱 对基本数据类型的装箱－NSNumber //装箱方法1 NSNumber *number = [NSNumber numberWithChar:&#39;X&#39;]; NSNumber *number = [NSNumber numberWithINT:23]; NSNumber *number = [NSNumber numberWithBOOL:YES]; NSNumber *number = [NSNumber numberWithDouble:34.5]; //装箱方法2 @23，@34.5 //开箱 [number charValue]; [number intValue]; [number BOOLValue]; [number DoubleValue]; 对所有非对象类型的装箱（包括基本数据类型）－ NSValue //对NSRect，NSPoint，NSRange装箱,也可以对基本数据类型进行装箱 NSRect rect = NSMakeRect(10,20,30,40); NSValue *value = [NSvalue valueWithBytes:&amp;rect objCType:@encode(NSRect)]; int a ＝ 5； NSValue *value = [NSvalue valueWithBytes:&amp;a objCType:@encode(int)]; //开箱 NSRect rect2 ＝ ｛0｝； ［value getValue:&amp;rect］; int b = 0; [value getValue:&amp;b]; //仅对NSRect，NSPoint，NSRange装箱 NSValue *value = [NSValue valueWithRect]; NSValue *value = [NSValue valueWithRange]; NSValue *value = [NSValue valueWithPoint]; //开箱 NSRect rect2 ＝ ｛0｝； [value rectValue]; NSRange range = {0}; [value rangeValue]; NSPoint point = {0}; [value pointValue]; 枚举//normal enumerator NSEnumerator *enumer = [array objectEnumerator]; id obj; while (obj = [enumer nextObject]) { NSLog(@&quot;%@&quot;,obj); } NSEnumerator *enumer2 = [array reverseObjectEnumerator]; while (obj = [enumer2 nextObject]) { NSLog(@&quot;%@&quot;,obj); } //fast enumerator for (id obj2 in array) { NSLog(@&quot;%@&quot;,obj2); } 类别 类别的简述 为现有的类（自定义的类、第三方的类或者是系统定义的类）添加一些新的行为； 类别可以解决继承不能为累簇添加新方法的问题。 类别的声明和实现 格式： 类名 ＋ 类别名 如：为NSString 创建一个类别 NSString＋NumberConvenience； 只要保证类别名称唯一，可以向一个类中添加任意数量的类别。 声明： @interface NSString （NumberConvenience） － （NSNumber *）lengthAsNumber; @end 实现： @implementation NSString （NumberConvenience） － （NSNumber *）lengthAsNumber { } @end 类别的优缺点 缺点： * 只能添加方法，只可以访问原始类的实例变量，无法向类别中添加新的实例变量 * 名称冲突。类别具有最高优先级，即当类别中定义与对应类中已有的方法同名的方法，对象调用该方法时，会优先调用类别中定义的方法。 * 多个Category中如果实现了相同的方法，只有最后一个参与编译的才会有效 优点： * 将类的实现代码分散到多个不同文件或框架中。 * 可以创建对类中私有方法的前向引用， * 向对象添加非正式协议。 使用类别实现类的扩展 类的扩展等同于在类声明的源代码中声明一个无名的（即括号“ （） ”里面为空）类别，并实现； 类的扩展可以在源代码中使用 可以添加实例变量作为类的私有变量和方法 可以将只读权限改为读写权限 创建数量不限 利用类别分散实现代码的优点 . 在大型的项目中， 一个类的实现可能非常大，并且.m文件不能分离。但是使用类别可以将一个类的实现分散且有规律的组织在不同的文件中。还可以将一个类的实现分散到不同的框架中。 . 编程人员可以更加容易阅读代码并实现多人合作编码 . 版本管理降低冲突 . 维护人员更容易理解代码 非常正式协议 非正式协议就是为NSObject类创建一个类别； 响应选择器 使用@selector()编译指令来指定选择器,圆括号里是具体的方法名。如： 1234（有几个参数要有几个冒号“ : ”） 如： @selector(setEngine:) @selector(setTire:atIndex:) - 选择器的类型关键字:SEL - \\- (BOOL)respondsToSelector:(SEL)@Selector; 使用此方法可以判断某一对象是否可以执行指定的方法。 1QYStudent *student = [[QYStudent alloc]init]; 如： 1[student respondToSelector:(SEL)@selector(study)]; //对对象student判断其是否有study这个方法，有的话返回值为YES，没有的话返回值为NO。 协议 基本用途 可以用来声明一大堆方法（不能声明成员变量） 只要某个类遵守了这个协议，就相当于拥有这个协议中的所有方法声明 只要父类遵守了某个协议，就相当于子类也遵守了 格式 @protocol 协议名 方法声明列表 @end 某个类遵守某个协议 @interface 类名 : 父类名&lt;协议名&gt; @end 关键字 协议中有2个关键字可以控制方法是否要实现（默认是@required），在大多数情况下，用途在于程序员之间的交流 @required: 该关键字以下且@optional关键字以上的方法必须要实现（若不实现，编译器会发出警告 @optional: 该关键字以下且@required关键字以上的方法可以选择性的实现 协议遵守协议 一个协议可以遵守其他多个协议，多个协议之间用逗号 , 隔开 一个协议遵守了其他协议，就相当于拥有了其他协议中的方法声明 @protocol 协议名称 &lt;协议1, 协议2&gt; @end 基协议 NSObject是一个基类，最根本最基本的类，任何其他类最终都要继承它 其实还有一个协议，名字也叫NSObject，它是一个基协议，最根本最基本的协议 NSObject协议中声明很多最基本的方法，比如description、retain、release等 建议每个新的协议都要遵守NSObject协议 定义变量时指定协议 // NSObject类型的对象，并且要遵守NSCopying协议 NSObject *obj; // 任何OC对象，并且要遵守NSCoding协议 id obj2; 内存管理内存管理机制：引用计数 引用计数的计算 alloc 、new 、copy(copy生成接收对象的一个副本) //使用这三个方法创建对象时，对象的引用计数器为1 - (id) retain; //给对象发送retain消息后，对象的引用计数器加1 - (void) release; //给对像发送release消息后，对象的引用计数器减1 - (void)dealloc; //当一个对象的引用计数器变为0而即将被销毁时,Objective-C自动向对 象发送一条dealloc消息，我们通常都会在自己的对象中重写dealloc方法 - (unsigned) retainCount;//获取当前对象的引用计数器的值 非ARC环境下内存的管理 当某个对象被持有有，［对象名 retain］； 当某个对象不再被持有时，［对象名 release］； ARC环境下内存的管理 规则 只要还有一个强指针变量指向对象，对象就会保持在内存中 强引用，弱引用 ➢ 默认所有实例变量和局部变量都是Strong指针 ➢ 弱指针指向的对象被回收后，弱指针会自动变为nil指针，不会引发野指针错误。其修饰符号为__weak; 注意点 ➢ 不能调用release、retain、autorelease、retainCount ➢ 可以重写dealloc，但是不能调用[super dealloc] ➢ @property : 想长期拥有某个对象，应该用strong，其他对象用weak ➢ 其他基本数据类型依然用assign ➢ 两端互相引用时，一端用strong、一端用weak 自动释放池 自动释放池是一个存放实体的集合，这些实体可能是对象，这些对象能够被自动释放。 / - (id) autorelease; //是NSObject类提供的方法，此方法在某一个预定的时候，向对象发送release消息，返回值是接收消息的对象。实际上当给一个对象发送autorelease消息的时候，就是将这个对象添加到的自动释放池(NSAutoreleasePool)中，当自动释放池销毁时，会向该池中的所有对象发送release消息。 如： - (NSString ) description { NSString desc; desc = [[NSString alloc] initWithFormat: @” I am %d years old”,29]; return ([desc autorelease]); } 内存管理规则 如果我使用了new , alloc 或者copy方法获得一个对象，则我必须释放或自释放该对象。 如果你对对象调用了retain消息，那么你必须负责释放(release)这个对象，保证retain和release的使用次数相等。 拷贝 浅拷贝（shallow copy） 不会复制所引用的对象，新复制的对象只会指向现有的引用对象上。（引用计数加 1 ，地址不变） 深拷贝（deep copy） 真正意义的复制概念。得到的结果是多个，而非只是对象的引用。（引用计数 不变 ，地址发生变化） 关键字 copy：对不可变的集合copy为浅拷贝，对可变的集合copy为深拷贝 mutableCopy：对可变的或不可变的集合mutableCopy都是深拷贝，但是对于集合内部对象的拷贝时浅拷贝。 BLOCK 基本概念 代码块本质上是和其他变量类似。不同的是，代码块存储的数据是一个函数体。使用代码块时，可以像调用其他标准函数一样，传入参数数，并得到返回值。 * Block封装了一段代码,可以在任何时候执行 * Block可以作为函数参数或者函数的返回值，而其本身又可以带输入参数或返回值。 * 苹果官方建议尽量多用block。在多线程、异步任务、集合遍历、集合排序、动画转场用的很多 定义 int (^MySum)(int, int) = ^(int a, int b) { return a+b; }; 定义了一个叫MySum的blocks对象，它带有两个int参数，返回int。等式右边就是blocks的具体实现 对变量的访问权限 对全局变量具有读写权限 对静态变量具有读写权限 对局部变量只有访问权限（可以用__block修饰局部变量，这样可以对其进行修改） 与函数指针的对比 定义函数指针 int (p)(int,int); *定义Blocks int (^Blocks)(int,int); 调用函数指针 (p)(10, 20); *调用Blocks Blocks(10, 20); typedef和赋值 在声明的同时定义变量，然后赋值int (^MySum)(int,int) = ^(int a,int b) {return a + b;}; 也可先用typedef先声明类型，再定义变量进行赋值typedef int (^MySum)(int,int);MySum sum = ^(int a,int b) {return a + b;}; KVC（Key Valuble Coding） 基本概念 是一种间接更改对象状态（或者说是属性值）的方式：key-value coding 简称KVC. 主要本质特点是采用字符串来标识对象的属性变量，并可以利用这个标识来更改对象的状态（或者说是属性值） 基本用法 / - (id)valueForKey:(NSString *)key //以key作为标识符，获取其对应的属性值 / - (void)setValue:(id)value forKey:(NSString *)key //以key作为标识符设置其对应的属性值。 调用机制 valueForKey:会首先查找以参数名命名（格式为-key或者isKey)的getter方法，如果找到的话则调用这个方法；如果没有找到这样的getter方法，它将会在对象内部寻找名称格式为_key或者key的实例变量，然后返回。 setValue:forKey:的机制跟valueForKey相似。它首先查找参数名命名的setter方法，如果找到的话则完成设置；如果没有找到setter方法， 则直接在类中找到名称格式为_key或者key的实例变量， 然后将value赋值给它。 键路径 键路径的概念和表示：可以在对象和不同的变量名称之间用圆点分开来表示。 -(id)valueForKeyPath:(NSString *)keyPath //以keyPath作为标识符，获取其对应的属性值 -(void)setValue:(id)value forKeyPath:(NSString *)keyPath //以keyPath为标识符，设置其对应的属性的值。 ##通配符 《系统级别》 {} touch {1,2,3,4,6,a,c,b,hello,t}.c // 同时创建 1.c,2.c,3.c,4.c,6.c,a.c,c.c,b.c,hello.c,t.c文件 * ls *.c //列出所有以 .c为后缀的文件 ? ls ??h*.c //列出第三个字符为“h”，且以.c为后缀的所有文件 [] ls [0-9].c //列出以数字0-9为文件名的.c文件 ! ls ![0-9].c //列出所有不是以数字0-9为文件名的.c文件 谓词 谓词的定义 谓词使用了KVC机制。 NSPredicate *predicate = [[NSPredicate prdicateWithFormat:@string]]; //实历化一个谓词对象. NSArray predicateArr = [对象名 filteredArrayUsingPredicate predicate]; //向对象发消息，过滤出满足谓词条件的内容，并存放到数组predicateArr中； （filteredArrayPredicate:NSPredicate 方法的返回值时NSArray 类型） 谓词中的操作符 谓词操作符不区分大小写 关系运算符 { &gt; &lt; &gt;= &lt;= == != } 逻辑运算符 {&amp;&amp;(and) ||(or) !} 1NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;name != &apos;lisi&apos; and age &gt; 12&quot;]; * 范围运算符 `{between in}` 1234predicate = [NSPredicate predicateWithFormat:@&quot;age in &#123;23,25&#125;&quot;];//仅仅过滤出 age ＝ 23 和 age ＝ 25 的信息predicate = [NSPredicate predicateWithFormat:@&quot;age between &#123;23,25&#125;&quot;];//过滤出 23 &gt;= age &lt;＝ 25 的信息 * 通配符 `{* ? 主要与like一起使用}` 12predicate = [NSPredicate predicateWithFormat:@&quot;name like &apos;??a*&apos;&quot;];//过滤name第三个字母为a的信息 * 字符串特有操作符 `｛contains like endswith beginswith ［c］不区分大小写［d］不区分音节［cd］｝` 12predicate = [NSPredicate predicateWithFormat:@&quot;name endswith[cd] &apos;u&apos; and name contains[cd] &apos;ao&apos;&quot;];//过滤name以‘u’结尾 且 包含 “ao”的信息 * 集合中的操作符 `{ANY ALL}` 1234567predicate = [NSPredicate predicateWithFormat:@&quot;ALL age &gt; 10&quot;]; if ([predicate evaluateWithObject:Arr]) &#123; NSLog(@&quot;evaluable&quot;); &#125;else &#123; NSLog(@&quot;It&apos;s not evaluable &quot;); &#125; //判断数组Arr中的对象中age是否全部大于10 * 谓词模板 `{$ %K}` 12345678NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age between $RANGE&quot;]; NSArray *arr = @[@20,@50]; NSDictionary *dic = @&#123;@&quot;RANGE&quot;:arr&#125;; //过滤 20 &gt;= age &lt;= 50的信息 NSString *keyPath = @&quot;age&quot;; predicate = [NSPredicate predicateWithFormat:@&quot;%K &gt; %@&quot;,keyPath,@20]; //过滤age &gt; 20 的信息 正则表达式 《工具级别》选择 | 竖直分隔符代表选择。例如，“grey | gray”可以匹配grey或gray 数量限定 +号代前面的字符至少要出现一次，可以出现多次。例如，“goo + gle”可以匹配google,gooogle,goooogle等 ？号代表前面的字符最多只能出现一次，可以不出现。例如，“colour？r”可以匹配color或者colour 星号代表前面的字符可以不出现，可以出现一次或多次。例如，”0\\42”匹配42，042，0042，0004等。 “{n}”代表前面的字符要出现n次，“{2，6}”代表前面的字符可以选择性的出现2-6次，例如，”go{2}gle”可以匹配google 匹配“（）”圆括号可以用来定义操作符的范围和优先度。例如，“gr(a|e)y”等价与“gray|grey”,”(grand)?father” 可以匹配father和grandfather。 ^ $符号 ^符号代表开始，例如，“^b”可以匹配以字符b开始的一类字符串 $符号代表结束，例如，“x$”可以匹配以字符x结束的一类字符串，“^$”代表空 .符号 .点符号，代表可以是任意字符。例如，“^a.{3}[0-9]+eh(hello)$”可以匹配ad_dehhello,a23d4ehhello,asdf345ehhello等 1以上规则可以综合使用 正则表达式可以用在grep，awk，sed，gas，find，等命令中， grep | ‘[a-z]{5}zsh$’ dotfiles 过滤dotifiles目录下的所有文件及目录 ls | grep ‘^d’ ls命令列出当前目录下的以d开头的文件包括目录 grep | -R ‘hello’ ./* 递归的查看根路径下的所有包含hello字符串的内容（-RE 递归的查找，支持正则表达式） find . -name ‘hello’查看名字为hello的文件的路径， find . -type d 查看当前目录下的所有文件夹的路径 sed -RE ‘/^_.*(false)$/‘ /etc/passwd 查看passwd文件内容不是以下划线开始且以false结束的内容","tags":[{"name":"oc","slug":"oc","permalink":"https://github.com/xiao-xi/tags/oc/"}]},{"title":"cocoa内存管理","date":"2014-10-20T14:02:53.000Z","path":"2014/10/20/cocoa内存管理/","text":"##引用计数的概念以办公室开灯关灯举例 ##内存管理的思考方式 ###自己⽣成的对象,自己持有 * alloc * mutableCopy ￼* new ￼* copy 自⼰生成并持有对象 id obj = [[NSObject alloc] init]; ￼￼ ###非自己生成的对象,自己也能持有￼￼ 取得非⾃⼰⽣成的对象但⾃⼰不持有对象 id obj = [NSMutableArray array]; ￼￼ 取得⾮自⼰⽣成的对象但⾃己持有对象 id obj = [NSMutableArray array]; ⾃己持有对象 [obj retain]; ￼￼￼ ###不再需要自己持有的对象时释放 ￼￼￼ ⾃⼰⽣成并持有对象 id obj = [[NSObject alloc] init]; ⼀一般会在release之后,将对象指针赋为nil,以避免指针悬空的情况 obj = nil; ￼释放对象 ￼[obj release]; 取得非⾃己⽣成的对象但⾃⼰持有对象 id obj = [NSMutableArray array]; ￼￼⾃⼰持有对象 ￼[obj retain]; ￼释放对象 ￼[obj release]; ￼obj = nil; ￼ ###非自己持有的对象无法释放￼￼ ￼自己生成并持有对象 id obj = [[NSObject alloc] init]; /释放之后再次释放已⾮自己持有的对象,应⽤用程序会崩溃 [obj release]; ￼ 释放对象 ￼[j release]; ￼⼀一般会在release之后,将对象指针赋为nil,以避免指针悬空的情况 ￼ obj = nil; ￼ ￼ 取得非自己生成的对象且自己不持有该对象 id obj = [NSMutableArray array]; 释放了⾮⾃己持有的对象,会导致应用程序崩溃 [obj release]; ￼￼￼ ￼ ⾃⼰生成并持有对象 id obj = [[NSObject alloc] init]; ⼀一般会在release之后,将对象指针赋为nil,以避免指针悬空的情况 obj = nil; ￼释放对象 ￼[obj release]; ￼ ##ARC规则 ###所有权修饰符 __strong修饰符 ￼__weak 修饰符 ￼__unsafe_unretained修饰符 __autoreleasing __strong 修饰符 __strong修饰符表示对象的“强引用”。持有强引用的变量在超出其作用域时被废弃,随着强引用的失效,引⽤的对象会随之释放。 Demo __strong修饰符修饰的变量,不仅只在变量作⽤域中,在赋值上也能正确地管理其对象的所有者。 Demo strong修饰符同后面要讲的_weak修饰符和autoreleasing修饰符⼀一起,可以保证将附有这些修饰符的自动变量初始化为nil。 Demo __weak 修饰符 循环引用容易发⽣内存泄露。所谓内存泄露就是应当废弃的对象在超出其生存周期后继续存在。 Demo __weak修饰符在持有某对象的弱引用时,若该对象被废弃,则此弱引用将⾃动失效且处于nil被赋值的状态(空弱引用) Demo __unsafe_unretained 修饰符 附有unsafe_unretained 修饰符的变量不属于编译器的内存管理对象 Demo 赋值给附有unsafe_unretained修饰符变量的对象在通过该变量使用时,如果没 有确保其确实存在,那么应用程序就会崩溃 Demo __autoreleasing 修饰符 ￼￼*在使⽤ARC时,不能使用autorelease⽅方法,也不能使用NSAutoreleasePool类 指定”@autoreleasepool块”来替代”NSAutoreleasePool”类对象生成、持有以及废弃这⼀范围 另外,要通过将对象赋值给附加了__autoreleasing修饰符的变量来替代调用autorelease⽅方法 Demo* #####显式的附加autoreleasing修饰符同显式地附加strong修饰符一样罕见,原因如下: ( 考虑两种使用autoreleasepool的场景 ) 非自己生成并持有的对象: 编译器会检查方法名是否以alloc/new/copy/mytableCopy开始, 如果不是就说明是⾮自己生成并持有的对象, 编译器会自动将返回的对象注册到autoreleasepool中 ￼￼自己生成并持有的对象,在函数中返回时: 由于return使得对象变量超出其作用域, 所以强引⽤对应的⾃己⽣成并持有的对象会被自动释放, 但该对象如果作为函数的返回值, 编译器会自动将其注册到autoreleasepool中","tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://github.com/xiao-xi/tags/内存管理/"}]},{"title":"hexo搭建","date":"2014-10-20T13:37:23.000Z","path":"2014/10/20/hexo搭建/","text":"1.安装nvm(node.js的版本管理工具） $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 2.添加如下内容到.zshrc配置文件 [ -s &quot;/Users/`users`/.nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/Users/`users`/.nvm/nvm.sh&quot; # This loads nvm 3.安装node.js(通过nvm安装) $ nvm install 0.10 4.安装hexo（通过npm安装） $ npm install -g hexo 5.创建hexo文件夹，并安装hexo相关组件 $ hexo init hexo $ cd hexo $ npm install 6.本地查看 输入如下命令后，打开浏览器，并输入localhost:4000来查看 $ hexo g $ hexo s 7.注册github账号 创建github账号同名repository eg:github账号名位dorayox，则创建dorayox.github.io 部署到github上 8.如下所示编辑_config.yml deploy: type: github repository: git@github.com:dorayox/dorayox.github.io.git branch: master 9.输入如下命令，完成到github得部署，之后打开浏览器并输入dorayox.github.io来查看 $ hexo g $ hexo d 若hexo仍不能用则进行下面操作： 检查 ～ 目录下 .nvm 是否 git 化，若是则删除其中 .git 删除， 进入 .nvm/v0.10.32/bin 目录下复制 Users/qingyun/.nvm/v0.10.32/bin 目录， 再次进入 ～目录下，vi .zshrc设置路径 export PATH=$PATH:/Users/qingyun/.nvm/v0.10.32/bin 退出iterm重新进入，cd hexo ， 再次运行hexo命令如：hexo s","tags":[{"name":"Mac上搭建hexo极简指南","slug":"Mac上搭建hexo极简指南","permalink":"https://github.com/xiao-xi/tags/Mac上搭建hexo极简指南/"}]},{"title":"vim使用","date":"2014-10-20T13:00:50.000Z","path":"2014/10/20/vim使用/","text":"vim编辑器使用 C语言函数 函数定义 函数声明 函数嵌套(new) gcc编译器 预处理 gcc -E 编译 gcc -S 汇编 gcc -c 链接 调试 gcc -g 指定输出名字 gcc -o 开启警告提醒 gcc -Wall lldb调试器 list (l) break (b) run (r) next (n) step (s) continue (c) quit (q) unix/linux常用符号 ^ $ &gt; &lt; ! (!!、!gcc) ? ($?) unix/linux常用命令 cd ls pwd cat cp mv mkdir touch echo unix/linux的环境变量￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼ 1$HOME $PATH ###sizeof运算符详解 1. sizeof(char) 2. sizeof(short) 3. sizeof(int) 4. sizeof(long) 5. sizeof(float) 6. sizeof(double) 7. sizeof(char *) 8. sizeof(int *) 9. sizeof(array) ###字符串操作 1. atoi/atol(将字符转换成整数) 2. strtod/strtol (将字符串转换成小数) 3. tolower/toupper (大小写字母转换) man ctype - man tolower 4. strcmp/strcasecmp(字符串比较) 5. strchr/strstr 6. strcpy/strncpy 7. strcat/strncat 8. strlen ###内存操作 1. malloc - free 2. memset 3. memcpy 4. memcmp","tags":[{"name":"vim的使用","slug":"vim的使用","permalink":"https://github.com/xiao-xi/tags/vim的使用/"}]},{"title":"Git 操作","date":"2014-10-20T11:33:41.000Z","path":"2014/10/20/Git-操作/","text":"Git 操作基本操作 初始化仓库 。git init 配置作者信息 。git config –global user.email”youremail@corp.com” 。git config –global user.email”youremail@corp.com” 添加文件到暂存区 。git add 。git add * (添加所有文件到暂存区) 移除文件 。git rm 重命名一个文件 。 git rm 提交暂存区 。 git commit只会提交暂存区(staged)⾥面的⽂件 。 git commit -m “message” 查看工作目录的状态 。 git status 查看提交历史记录 。 git clone 查看文件改变 。 git diff 撤销操作 撤销加入暂存区的操作 。git reset HEAD \\ 撤销修改的操作 。git checkout – \\ 将本地的修改放进回收站 。git stash 从回收站中恢复本地的修改 。git stash apply ￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼ ￼Tag操作 查看tag 。git tag 创建tag 。git tag -a v1.0 -m “my version 1.0” 显示tag信息 。git show v1.0 对之前的提交打tag 。git tag -a v0.1 -m “version 0.1” 分支操作 查看分支 。git branch 创建分支 。git branch 删除分支 。git branch -d 切换分支 。git checkout 合并分支 。git merge rebase操作 。git rebase 远端仓库操作 克隆一个远端仓库 。git clone URL 添加远端仓库 。git remote add 更新远端仓库的分支和数据 。git fetch 获取并合并远端仓库的分支到当前分支 。git pull 。eg: git pull origin master 上传本地分支和数据到远端仓库 。git push 。eg: git push origin master 跟踪远端仓库上的分支 。git checkout –track origin/testbranch 。git checkout -b test origin/testbranch￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼","tags":[{"name":"Git 操作","slug":"Git-操作","permalink":"https://github.com/xiao-xi/tags/Git-操作/"}]},{"title":"accelerator-key","date":"2014-10-20T11:06:05.000Z","path":"2014/10/20/Xcode常用命令/","text":"Base Keycommand + c : 复制选中的内容 command + v : 粘贴已复制的内容 command + X : 剪贴已选中的内容 command + z : 撤销最近一次执行放入操作 command + / : 选中多行，一次注释多行 Move Keyctrl + a : 移动光标到行首 ctrl + e : 移动光标到行尾 ctrl + p : 向上移动光标 ctrl + n : 向下移动光标 ctrl + b : 向左按字符移动光标 ctrl + f : 向右按字符移动光标 ctrl + option + b : 向左按符移动光标 ctrl + option + f : 向右按符移动光标 Select Keyctrl + shift + b : 从光标处向左按字符选中 ctrl + shift + f : 从光标处向右按字符选中 ctrl + shift + p : 从光标处向上按行选中 ctrl + shift + n : 从光标处按行向上选中 Delete Keyctrl + d : 删除贯标右边的字符，按字符删除 ctrl + h : 删除贯标左边的字符，按字符删除 ctrl + k : 删除光标所在位置之后的所有内容 Key – XCodecommand + shift + 0 : 打开官方文档 command + shift + n : 创建一个工程 commanf + n : 创建一个类、协议、类别、累扩展等 command + b : 编译代码 command + r : 运行生成的代码 command + shift + k : 清空XCode之前的编译 command + shift + -&gt;/&lt;-;(左方向键) : 切换页面 commang + f : 在官方文档中调出搜索栏 comand + option + enter : 分栏 command + enter : 回到一栏 command + ctrl +左右键 : 不同页面的切换 shift + tab : 选中上一个 tab : 选中下一个 other keycommand + ctrl + f : 切换当前应用程序界面的大小，同时将桌面背景消失，只显示当前应用程序 command + option + “+” : vim终端界面的大小切换 ctrl + 左右键 : 桌面快速切换 ctrl + 上键 : 已开应用程序，分布呈现在当前桌面 ctrl + 下键 : 呈现当前应用程序已开启的所有窗口，以及使用当前应用程序开启的历史文件 command + tab : 快速向后选择桌面已开启的应用程序 command + tab + shift : 快速向前选择桌面已开启的应用程序","tags":[{"name":"accelerator-key","slug":"accelerator-key","permalink":"https://github.com/xiao-xi/tags/accelerator-key/"}]},{"title":"Hello World","date":"2014-09-20T10:55:26.000Z","path":"2014/09/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in trobuleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://github.com/xiao-xi/tags/Hello-World/"}]},{"title":"xml笔记","date":"2014-09-06T08:51:01.000Z","path":"2014/09/06/xml笔记/","text":"#XML1.什么是XML？ XML：Extensible Markup Language(可扩展标记语言） 传输数据而非显示数据 (区别于HTML) 标签没有没预定，需要自行定义标签，具有自我描述性 被设计为传输和存储数据，焦点是数据的内容 2.XML的特点？ 仅仅是纯文本 可以发明自己的标签 3.XML的优点？ 简化数据\u000e共享 简化数据传输* 简化平台变更 使数据更有用：独立于硬件、软件及应用程序 4.树结构？（重点） 例子： &lt;bookstore&gt; &lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt; 注释：例子中的根元素是 bookstore。文档中的所有book元素都被包含在 bookstore 中。 * 创建xml文件与plist文件一样，将后缀改为xml; 5.语法规则 *XML必须有根元素 *XML必须有关闭标签 *XML标签对大小写敏感 *XML元素必须被正确嵌套 *属性必须加双引号 6.XML解析 (NSXMLParser解析方法)*SAX: （！！只能读不能修改，解析速度快） 1）SAX（Simple APIs for XML），典型特点是：事件驱动，实现对XML的解析 2）对文档的解析 3）顺序访问机制，不能倒回去重新处理 DOM：（！！不仅能读，还能修改，解析速度慢） DOM （Document Object Model，文档对象模型）定义了访问和操作文档的标准方法。*1） 数结构 *区别：SAX：遇到根元素进行初始化，顺序读下去，每读一行解析一行，基于事件的， 消耗内存比较小；DOM：一次性把文件读入内存，我们可以读任意一个节点或者属性，消耗内存较大；一般用于服务器中 苹果内部用的是SAX 7.常用解析框架 (常用) 1)SAX::NSXMLParser 这是一个SAX方式解析XML的类库，默认包含在 iOS SDK中，使用也比较简单。 2)DOM::GDataXML，http://code.google.com/p/gdata- objectivec-client/source/browse/trunk/Source/ XMLSupport/，这是一套Google开发的DOM方式XML解析类库，支持读 取和修改XML文档，支持XPath方式查询。 3)libxml2:同时支持SAX 和DOM **#：解析步骤： 1&gt;.对于SAX： 获取XML文件的路径 根据URL 来创建XML的解析器NSParser对象 设置XML解析器的代理（用代理方法解析） 开始解析 2&gt;.对于DOM：（用GDataXML第三方库） 获取XML文件的路径或者URL 根据URL路径，把文件读入内存中（NSData对象：data） 通过data对象创建DataXMLDocument （doc）对象 取出XML的根元素（[doc \u001drootElement]方法）; 由于doc在内存中是树形结构，可以根据子元素的名字取出所有该子元素 的子元素 遍历所有子元素，依次解析出子元素的属性和文本内容 for (GDataXMLElement *element in elements) [element attributeForName:kCategory]方法 ##JSON 1.JSON定义和特点： JSON （JavaScript Object Notation） JavaScript 对象表示法 JSON 是轻量级的文本数据交换格式 JSON 独立于语言 JSON 具有自我描述性，更易理解 2.JSON格式：（数组或者字典） [ { &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 30, &quot;phone&quot;: [ &quot;123456&quot;, &quot;654321&quot; ], &quot;address&quot;: { &quot;country&quot;: &quot;china&quot;, &quot;province&quot;: &quot;henan&quot; }, &quot;married&quot;: false }, { &quot;name&quot;: &quot;lisi&quot;, &quot;age&quot;: 40, &quot;phone&quot;: [ &quot;123456&quot;, &quot;654321&quot; ], &quot;address&quot;: { &quot;country&quot;: &quot;china&quot;, &quot;province&quot;: &quot;henan&quot; }, &quot;married&quot;: false } ] ##*** array 中可以放置的value类型： string,number ,object ,array ,true ,false ,null 3.JSON解析步骤 取出文件URL 创建data 使用NSJSONSeriazilation 来解析data(接收用数组还是字典根据文件 而定) 一个一个元素解析，或者用字典遍历 4.JSON有用的网站 JSON格式校验网站：http://jsonlint.com www.json.org www.bejson.com (格式校验，开放接口等) 5.json 的解析框架：JSONKit（不常用，版本较低） 和 NSJSONSeriazilation（系统的，主流的） www.json.org 网址上打开JSONKit选项然后复制网址，执行 git clone https://github.com/johnezang/JSONKit.git (复制的网址) ##第三方库的应用 添加库：Building setting –&gt;搜索include /Header Search …选项，双击添加提示的库路径 链接：Building setting –&gt;搜索link/Other linker flags … 选项–&gt; 双击添加链接 编译ARC和非ARC ：Building phase –&gt;找到Compile Source …选项 –&gt;在非ARC得文件后面添加“-fno-objc-arc ” #JSON与XML解析程序： 1.URL-&gt;NSRequest 2.[NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse response, NSData data, NSError *connectionError) { 1&gt;JSON步骤如下: // 反序列化 NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:0 error:NULL]; // 建立数组 NSMutableArray *arrayM = [NSMutableArray array]; [array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { Video *v = [[Video alloc] init]; [v setValuesForKeysWithDictionary:obj]; [arrayM addObject:v]; }]; dispatch_async(dispatch_get_main_queue(), ^{ self.videoList = [arrayM copy]; [self.refreshControl endRefreshing]; }); 12345678910 2) XML步骤： //1&gt; NSXMLParser *parser = [[NSXMLParser alloc] initWithData:data]; // 2&gt; 设置代理 parser.delegate = self; //3&gt; 开始解析 [parser parse]; }]; ##XML的代理方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172###pragma mark 1. 开始,准备工作，初始化一些数组，字符串- (void)parserDidStartDocument:(NSXMLParser *)parser&#123; NSLog(@&quot;开始解析文档&quot;); // 准备工作 // 1&gt; dataList // 2&gt; elementString // 清空可变字符串不要设置成nil,使用setString只是清空内容,下次不会再次实例化&#125;###pragma mark 2. 所有开始一个节点:&lt;element&gt;，开始节点都在这里进行- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict&#123; NSLog(@&quot;开始节点:%@ %@&quot;, elementName, attributeDict); // 如果是&lt;video&gt;新建对象 if ([elementName isEqualToString:@&quot;video&quot;]) &#123; self.v = [[Video alloc] init]; self.v.videoId = attributeDict[@&quot;videoId&quot;]; &#125; // 每开始一个新节点之前都清空elementString // 避免上一次的结果被重复拼接,例如拼完名字是&quot;abc&quot;,再拼长度就会变成&quot;vda1234&quot; [self.elementString setString:@&quot;&quot;];&#125;###pragma mark 3. 查找内容,可能会重复多次- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123; // 拼接字符串 [self.elementString appendString:string];&#125;###pragma mark 4. 节点结束 &lt;/element&gt;- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123; NSLog(@&quot;结束节点 %@&quot;, elementName); // 判断如果是&lt;name&gt;要复制 if ([elementName isEqualToString:@&quot;video&quot;]) &#123; [self.dataList addObject:self.v]; &#125; else if (![elementName isEqualToString:@&quot;videos&quot;]) &#123; [self.v setValue:self.elementString forKey:elementName]; &#125; // 提示:使用KVC只要是数值型的属性,kvc会自动设置成对应的属性,而无需程序员参与// if ([elementName isEqualToString:@&quot;name&quot;]) &#123;// self.v.name = self.elementString;// &#125; else if ([elementName isEqualToString:@&quot;length&quot;]) &#123;// self.v.length = [NSNumber numberWithInt:[self.elementString intValue]];// &#125;&#125;###pragma mark 5. 文档结束- (void)parserDidEndDocument:(NSXMLParser *)parser&#123; NSLog(@&quot;解析结束 %@ %@&quot;, self.dataList, [NSThread currentThread]); dispatch_async(dispatch_get_main_queue(), ^&#123; [self.tableView reloadData]; // 关闭刷新控件的刷新 [self.refreshControl endRefreshing]; &#125;);// [self.dataList enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;// NSLog(@&quot;%@&quot;, obj);// &#125;];&#125;###pragma mark 6. 出错处理- (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parseError&#123; NSLog(@&quot;%@&quot;, parseError.localizedDescription);&#125;","tags":[{"name":"IOS XML JSON","slug":"IOS-XML-JSON","permalink":"https://github.com/xiao-xi/tags/IOS-XML-JSON/"}]}]