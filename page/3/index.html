<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://github.com/xiao-xi">
  <title>chenxiaoxiang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="chenxiaoxiang">
<meta property="og:url" content="https://github.com/xiao-xi/page/3/index.html">
<meta property="og:site_name" content="chenxiaoxiang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chenxiaoxiang">
  
    <link rel="alternative" href="/atom.xml" title="chenxiaoxiang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css?v=4.0.0.css">
  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="http://ohvg3bz6c.bkt.clouddn.com/IMG_2462.JPG" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">xiao-xi</a></h1>
		</hgroup>

		
		<p class="header-subtitle">chenxiaoxiang</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a data-idx="0" q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
            
    			
    			<a data-idx="1" q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/xiao-xi" title="github"><i class="icon-github"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:xiao-xifff@foxmail.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">xiao-xi</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="http://ohvg3bz6c.bkt.clouddn.com/IMG_2462.JPG" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">xiao-xi</h1>
			</hgroup>
			
			<p class="header-subtitle">chenxiaoxiang</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/">随笔</a></li>
		        
		        
		        	<li><a href="/archives">所有文章</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/xiao-xi" title="github"><i class="icon-github"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:xiao-xifff@foxmail.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-C笔记" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/23/C笔记/">c-notes</a>
    </h1>
  

        <a href="/2014/10/23/C笔记/" class="archive-article-date">
  	<time datetime="2014-10-23T12:31:16.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-10-23</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://img2.3lian.com/img2007/14/03/20080405141042587.png" alt="image"></p>
<h3 id="间接-标准-统一-机制-策略"><a href="#间接-标准-统一-机制-策略" class="headerlink" title="间接  标准  统一  机制  策略"></a>间接  标准  统一  机制  策略</h3><h4 id="iTerm-的配置"><a href="#iTerm-的配置" class="headerlink" title="iTerm 的配置"></a>iTerm 的配置</h4><ol>
<li><p>将iTerm移到应用程序</p>
<p> 进入配置文件 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd iterm$zsh/.oh my zsh/templates</div></pre></td></tr></table></figure>
</li>
<li><p>ls 查看当前目录下的所有文件</p>
<p> 拷贝当前目录下的文件 zshrc.zsh-template 到~/.zshrc 下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp zshrc.zsh-template</div></pre></td></tr></table></figure>
</li>
<li><p>退出iterm，重启即可   </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ q</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="VI编辑器中的基本命令"><a href="#VI编辑器中的基本命令" class="headerlink" title="VI编辑器中的基本命令"></a>VI编辑器中的基本命令</h4><h5 id="VI编辑器中的基本内部命令"><a href="#VI编辑器中的基本内部命令" class="headerlink" title="VI编辑器中的基本内部命令"></a>VI编辑器中的基本内部命令</h5><p>在终端使用 vimtutor 命令可以查看VI编辑器中的基本命令</p>
<ol>
<li><p>复制命令</p>
<p>复制单个字符: y</p>
<p>复制一个单词: yw</p>
<p>复制所选中的一行: yy</p>
</li>
<li><p>移动命令<br>移动光标到行首: ^</p>
<p>向前移动一个单词: b</p>
<p>向后移动一个单词: w</p>
<p>向下翻一页: ctrl ＋ f </p>
<p>向上翻一页: ctrl ＋ b</p>
</li>
<li><p>d ＋ ^ 删除光标所在位置到行首的所有字符</p>
</li>
<li>d ＋ $ 删除光标所在位置到行尾的所有字符</li>
</ol>
<h5 id="VI编辑器中的基本外部命令"><a href="#VI编辑器中的基本外部命令" class="headerlink" title="VI编辑器中的基本外部命令"></a>VI编辑器中的基本外部命令</h5><ol>
<li><p>删除命令</p>
<pre><code>* rm ［filename］ 删除基本文件
* rm －r ［filename］ 有提示的删除一个文件夹
* rm －rf ［filename］ 强制删除文件夹，包括文件夹内的所有子文件夹以及自文件，且无提示 
 * rm \*~   (*为通配符)，即删除所有以～结尾的文件
</code></pre></li>
<li><p>拷贝命令</p>
<pre><code>* 若file2文件家不存在，默认将file1 拷贝一分命名为file2 
* 若file2时文件夹，默认将file1拷贝到文件夹file2下，且名字仍为file1 
* file1 file2 不加路径的情况下，默认是把当前路径下的文件拷贝到当前路径下 
* ile1 file2 表示为路径的形式，则是把指定路径下的file1 拷贝到指定路径下命名为file2，或是拷贝到制定路径下的file2文件夹下命名仍然是file1 
* cp －r/R ［file1］［file2］ 
* 将文件夹1拷贝到文件夹2目录下 
</code></pre></li>
<li><p>重命名（移动命令）</p>
<p> mv ［file1］［file2］</p><p></p>
<ul>
<li>若两文件在同一路径下且file2文件家不存在，默认将file1 重命名为file2</li>
<li>若file2时文件夹，默认将file1移动到文件夹file2下，且名字仍为file1<ul>
<li>file1 file2 不加路径的情况下，默认是把当前路径下的文件重命名为file2</li>
</ul>
</li>
<li>file1 file2 表示为路径的形式，则是把指定路径下的file1 移动到指定路径下命名为file2，或是移动到指定路径下的file2文件夹下命名仍然是file1</li>
</ul>
</li>
<li><p>其他命令</p>
<ul>
<li>ls －a列出当前目录下的所有文件及文件夹，包括隐藏文件（以 “.” 开始的文件或文件夹）其中 . 和 ..两个文件夹表示是当前路径和上级路径</li>
<li>cd 切换路径</li>
<li>du －h ［filename］ 默认为查看当前路径下人类可读的文件的大小，追加filename，则是查看该文件夹下的人类可读的文件的大小</li>
<li>diff ［file1］［file2］比较两个文件内容是否相同，相同的话无显示结果；不同的话，则列出不同之处</li>
<li>file ［file］ 查看该文件的类型（如二进制类型,ASCII,English等）</li>
<li>!!调出上次使用的命令<br>! +   使用过的命令的首字母后第一个单词，调出最近使用过包含该字母或单词的命令<br>ctrl ＋ r 搜索使用过的命令<br>ctrl ＋ c 结束当前输入的命令，即不执行当前输入的命令</li>
<li>gcc 执行命令时 加－g 可进行调试 （l 列出函数的源代码，b 设置断点，r 运行程序，n 执行下一步，s 进入函数内部，p ［var］ 打印变量var的值 q 退出程序 ）, 加 －save－temps 保留编译时生成的结果（即 .i, .s, .o 文件生成且被保留下来可供查看）</li>
<li>$?(echo $? 在屏幕上显示上次命令执行的结果，若执行成功则返回0，否则返回1；若上次执行是程序且执行成功则返回return 后的返回值)<br> echo $HOME 显示当前的home路径<br> echo $USER 显示当前的用户名</li>
<li>cat [filename] | head    查看文件的前十行内容<p></p><h4 id="注释方法"><a href="#注释方法" class="headerlink" title="注释方法"></a>注释方法</h4></li>
<li>// 注释一行</li>
<li><p>注释多行</p>
<ol>
<li>/*…*/ </li>
<li><p>#if 0</p>
<p> …</p>
<p> #else</p>
<p> …</p>
<p> #endif</p>
<p> 注释从 if 0 到else之间的多行，程序在编译，只编译else与endif之间的多行；若果把0换成非零值，则只</p>
</li>
</ol>
</li>
<li><p>头文件的保护</p>
<p>  #ifndef ［宏名］</p>
<p>   #define ［宏名］</p>
<p>   …</p>
<p>   #endif</p>
<p>   在引用头文件时，如果未定义头文件内已定义过的内容，则定义；否则，不再重复定义</p>
</li>
</ul>
</li>
</ol>
<h4 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h4><ol>
<li>函数作用域   仅限在一个函数中使用</li>
<li>文件作用域   仅限在一个文件中使用</li>
<li>代码快作用域  受限与“ ｛｝” 的限制</li>
<li>原型作用域    函数声明</li>
</ol>
<h4 id="变量的大小"><a href="#变量的大小" class="headerlink" title="变量的大小"></a>变量的大小</h4><ol>
<li>char  c 语言标准规定为1字节</li>
<li>int 一般为4字节  规定int的大小不超过long的大小，short的大小不超过int的大小</li>
<li>指针的大小与long的大小等于机器字长（即 32位os 其大小为4字节，64的os其大小为8字节），古可用sizeof(int)测试机器os时多少位的（sizeof只是一个操作符，并不是一个函数）。</li>
</ol>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>整型：char  short  int long </li>
<li>浮点型： float double</li>
<li>指针</li>
<li>聚合类型：数组，结构体，枚举类型</li>
<li>派生类型：字符串，联合体<h4 id="赋值操作-值得注意点"><a href="#赋值操作-值得注意点" class="headerlink" title="赋值操作 值得注意点"></a>赋值操作 值得注意点</h4></li>
<li>数组名是个地址，只能在初始化是对其赋值，在以后使用中，数组名是个地址常量，不能被作为左值对其赋值</li>
<li>对字符数组初始化赋值为字符串字面常量，相当于把全局数据段的字符串复制到栈对字符数组分配的地址中去。</li>
<li>指针是指针变量可以对其进行赋值运算</li>
<li>结构体类型的变量可以作为左值对其进行赋值</li>
</ul>
<h4 id="分配内存问题"><a href="#分配内存问题" class="headerlink" title="分配内存问题"></a>分配内存问题</h4><ul>
<li>在函数中定义变量，对其分配内存时不能太大</li>
<li>可使用全局变量在全局数据段分配大内存</li>
<li>可使用malloc（size）动态在堆中分配大内存，使用memset将申请的内存初始化。</li>
</ul>
<h4 id="字符串操作中段错误"><a href="#字符串操作中段错误" class="headerlink" title="字符串操作中段错误"></a>字符串操作中段错误</h4><ul>
<li>定义一个指向NULL地址的字符串指针<br> NULL的ascii值为0，地址为0的内存不可以被访问，故对该地址进行写操作是没有权限的。</li>
<li>在定义一个字符串数组时对其进行初始化为字符串字面常量<br> 对字符串数组定义并初始化为一个字符串字面常量时，字符数组首地址指向的是全局数据段的地址，对该段内存进行写操作是没有全县的。</li>
<li>使用strcpy，strcat，strcmp，strcasecmp等字符串操作函数，将目标字符串读／写爆。应该使用strncpy，strncat，strncmp，strncasecmp等字符串操作函数防止读写越界。</li>
</ul>
<h4 id="文件操作常用函数"><a href="#文件操作常用函数" class="headerlink" title="文件操作常用函数"></a>文件操作常用函数</h4><ol>
<li><p>字符读写 fgetc(FILE *fp);</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fputc(int c,FILE*fp);</div></pre></td></tr></table></figure>
</li>
<li><p>按行读写 fgets(char <em>str,size,FILE \</em>fp);</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fputs(char \*,size,FILE *fp);</div></pre></td></tr></table></figure>
</li>
<li><p>数据块读写 fread(char *,size,number,FILE *fp);</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fwrite(char \*, size,number,FILE \*fp);</div></pre></td></tr></table></figure>
</li>
<li><p>格式化读写 fprintf(FILE *fp,format,…);</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fsanf(FILE *fp,format,...);</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="三种缓冲机制"><a href="#三种缓冲机制" class="headerlink" title="三种缓冲机制"></a>三种缓冲机制</h6><ul>
<li>行缓冲  缓冲区存储一行信息才进行输出 eg：stdout（标准输出）</li>
<li>全缓冲  缓冲区存储满信息才进行输出</li>
<li>无缓冲  缓冲区只要有信息存储进去就进行输出  eg：stderr（报错）<h6 id="改变文件指针位置"><a href="#改变文件指针位置" class="headerlink" title="改变文件指针位置"></a>改变文件指针位置</h6><ul>
<li>rewind(FILE *fp);    改变指针指向头文件</li>
<li>fseek(FILE *fp,int length,long where);(where  可取值为SEEK_SET  SEEK_CUR   SEEK_END)   改变指针位置从（文件头部，当前位置，文件尾部）移动length个字节的位置<p></p></li>
</ul>
</li>
</ul>
<p><img src="http://www.52nx.net/article/UploadPic/2011-6/20116515532046548.png" alt="image"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/10/23/C笔记/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-OC笔记" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://www.52nx.net/article/UploadPic/2011-10/2011101515463073132.png" alt="image"></p>
<p>##NSLog 与 printf的不同</p>
<pre><code>1. NSLog接收oc字符串作为参数，printf接收c语言的字符串作为参数
2. NSLog输出后会自动换行，printf在输出后不会自动换行
3. 使用NSLog时，需要包含头文件#import &lt;Foundition/Foundition.h&gt;；而使用printf时，需要包含头文件#include&lt;stdio.h&gt;
4. NSLog可以输出日期，时间戳，进程号等信息，而printf不能输出这些信息
</code></pre><h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><p>面向过程 ： Procedure Oriented</p>
<p>面向对象 ： Object Oriented ，<strong>简称OO</strong></p>
<p>面向对象编程 ： Object Oriented Programming，<strong>简称OOP</strong></p>
<h2 id="OC-语法"><a href="#OC-语法" class="headerlink" title="OC 语法"></a>OC 语法</h2><ol>
<li><strong>类的声明</strong></li>
</ol>
<pre><code>@interface 类名：父类（默认为 NSObject 该类时根类）

{

    定义成员变量；（默认情况下，成员变量为protect类型，）

}    

（ 可以用@public将其定义为public类型，此时定义的属性或变量允许被外界访问）
@property(nonatomic/atomic,readonly/readwrite,assign/strong/retain/wake)类型 属性名；（定义属性可以自动生成setter和getter方法）

声明类方法；（标识 ＋ 该方法向类发消息）

声明实例方法； （标识 － 该方法向对象发消息） 声明类方法时 返回值最好定义为`instancetype`类型

@end
</code></pre><ol>
<li><p><strong>类的实现</strong></p>
<pre><code> @implemention 类名

 － 实例方法
｛
        实现代码； 
 ｝

 ＋ 类fangfa
｛ 
        实现代码； 
 ｝

 重写父类方法；
 如：descripition、 dealloc、init等

 @end
</code></pre><p>3.<strong>创建对象</strong></p>
<pre><code>1.包含所创建类的头文件
2.类名 ＊对象名；
2.1 类名 ＊对象名 ＝ ［［类名 alloc］init］；（创建对象并为其分配内存、初始化）
2.2 类名 ＊对象名 ＝ ［类名 new］；（每次都会创建出新的对象，并且返回对象的地址。）
3. 给对象赋值；（可以调用相应的类方法）；
4. 给对象发消息，完成所需要进行的操作；［对象 方法］；
</code></pre></li>
<li><p><strong>匿名对象</strong></p>
<pre><code>方法调用：

    ［［类名 new］方法］；／［［［类名 alloc］init］方法］；

属性访问：

    ［类名 new］-&gt;属性 ＝ 赋值；（外界访问定义为public类型的属性）
</code></pre></li>
</ol>
<h2 id="OC方法和函数的区别"><a href="#OC方法和函数的区别" class="headerlink" title="OC方法和函数的区别"></a>OC方法和函数的区别</h2><pre><code>1. OC方法的声明只能在@interface 和 @end之间，只能在@implementation 和 @end之间。即OC方法独立于类存在。
2. C函数不属于类，跟类没有联系，C函数所有权只属于定义函数的文件
3. C函数不能访问OC对象的成员变量。
</code></pre><h2 id="OC语法细节"><a href="#OC语法细节" class="headerlink" title="OC语法细节"></a>OC语法细节</h2><pre><code>1. 成员变量不能在｛｝中进行初始化、不能直接拿去访问
2. 方法的声明不能写在@end之后
3. 方法不能当作函数一样调用
4. 成员变量、方法不能用static等关键字进行修饰
</code></pre><h2 id="OC方法注意点"><a href="#OC方法注意点" class="headerlink" title="OC方法注意点"></a>OC方法注意点</h2><pre><code>方法只有声明，没有实现（经典错误，系统提示警告）
方法没有声明，只有实现（编译器警告，但是可以调用，OC的弱语法）
编译的时候，访问没有定义的成员变量直接报错，调用没有的方法，只是警告
没有@interface，纸偶@implemenation也可以成功定义一个类
        @implemenation Dog : NSObject
        {
            int _age;
            NSString *_name;
        }

        - (void)print
        {
            NSLog(@&quot;The dog&apos;s name is %@,ang de it&apos;s %d years old!&quot;,_name,_age);
        }
        @end

@implemenation 中不能声明和@interface一样的成员变量

OC中有`BOOL`基本数据类型，其值是`YES`和`NO`，而不是true 和false，它实际上是一种对带符号的自负类型（signed char）的定义（typedef），它使用8为存储空间。`YES定义为1，NO定义为0`；
</code></pre><p><img src="http://www.52nx.net/article/UploadPic/2011-7/2011772043927764.png" alt="image"></p>
<h3 id="类方法he实例方法"><a href="#类方法he实例方法" class="headerlink" title="类方法he实例方法"></a>类方法he实例方法</h3><ol>
<li><p><strong>类方法</strong></p>
<pre><code>＊ 该方法是直接可以用类名来执行的方法（类本身会在内存中占据存储空间，里面有类／对象方法列表）
＊ 以加号 ＋ 开头
＊ 只能用类名调用，对象不能调用
＊ 类方法不能访问实例变量（成员变量）
＊ 使用场合：当不需要访问成员变量时，尽量使用类方法
＊ 类方法和对象方法可以同名
</code></pre></li>
<li><p><strong>实例方法</strong></p>
<pre><code>＊ 该方法是用对象名来执行的方法
＊ 以减号 — 开头
＊ 只能用对象名调用，类不能调用，该方法没有对象是不能被执行的
＊ 对象方法能访问实例变量（成员变量）
</code></pre></li>
</ol>
<h3 id="setter和getter方法"><a href="#setter和getter方法" class="headerlink" title="setter和getter方法"></a>setter和getter方法</h3><ol>
<li><p><strong>setter和getter方法的使用场合</strong></p>
<pre><code>@public的成员可以随意被赋植，应该使用set和get方法来管理成员变量的访问
</code></pre></li>
<li><p><strong>setter方法</strong></p>
<pre><code>作用：用来设置成员变量，可以在方法里面过滤一些不合理的值
命名规范：方法以set开头，而且后面跟上成员变量名，成员变量名必须首字母大写，尽量形参名称不要与成员变量名重名（成员变量名最好以下划线 _ 开头）
返回值：一般为void
</code></pre></li>
<li><p><strong>getter方法</strong></p>
<pre><code>作用：返回对象内部的成员变量
命名规范：方法名和成员变量名同名
返回值：一般与成员变量的类型相同  
</code></pre></li>
</ol>
<h3 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h3><ol>
<li><p><strong>成员变量和局部变量同名</strong></p>
<pre><code>当成员变量和局部变量同名时，采取就近原则，访问的是局部变量
当self访问成员变量，区分同名的局部变量
</code></pre></li>
<li><p><strong>使用细节</strong></p>
<pre><code>1. 出现的地方：所有的OC方法中（对象方法／类方法），不能出现在函数
2. 作用：
    使用“self.属性”访问当前方法中的成员变量
    使用“self-&gt; 成员变量”访问当前方法中public成员变量
    使用“［self 方法］”调用方法（类方法／实例方法）
3. 类方法中self只能调用类方法，实例方法中self只能调用实例方法
</code></pre></li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p><strong>继承的概念</strong></p>
<pre><code>1. is－a机制
2. 即当创建的多个类有共同的属性和行为时，可以抽出一个类作为父类，在父类中定义相同的属性，声明实现相同的行为（方法）；
3. 子类可以使用父类的所有属性和方法，并且子类可以在父类的基础上拓补自己的属性和方法，包括重写父类方法。重写父类方法时，子类对象会优先调用子类重写后的方法。
4. 子类属性和方法访问的过程： 如果子类没有相应的方法或属性，则去访问父类，一次递进知道找到NSObject根类，如果仍然没有找到相对应的方法和属性，则报错。
</code></pre></li>
<li><p><strong>继承的专业术语</strong></p>
<pre><code>父类／超类    superclass
子类 subclass／subclasses
</code></pre></li>
<li><p><strong>继承的细节</strong></p>
<pre><code>单继承，不支持多继承
子类和父类不能有相同的成员变量
子类可以重写父类中声明的方法（在代码运行时，oc确保调用相应类的重写方的实现）
</code></pre></li>
<li><p><strong>继承的优缺点</strong></p>
<pre><code>优点：
在不改变原来模型的基础上，拓充方法
建立了类与类的联系
抽取了公共代码

缺点：
耦合性强
</code></pre></li>
<li><p><strong>super关键字</strong></p>
<pre><code>super既不是参数，也不是实例变量，而是oc编译器提供的功能
用于提供一种在子类中显示调用父类的方法    
</code></pre></li>
<li><p><strong>继承的局限性</strong></p>
<pre><code>父类不能访问子类属性、调用子类方法
不能继承累簇（如 NSString累簇）
</code></pre></li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ol>
<li><p><strong>多态的基本概念</strong>    </p>
<pre><code>某一类事物的多种形态
OC对象具有多态性
</code></pre></li>
<li><p><strong>多态的体现</strong></p>
<pre><code>主要体现在继承下：向不同的对象发相同的消息，其呈现的行为不一样。（如DrawShape程序中，向不同图像的对象发送draw消息，其打印结果是不同的）。
子类对象可以赋值给父类指针；
如：Father *f = [children new];
父类指针可以访问对应的属性和方法
如： f.age = 23;  
    [f study];
</code></pre></li>
<li><p><strong>多态的好处</strong></p>
<pre><code>用父类接收参数，节省代码
</code></pre></li>
<li><p><strong>多态的局限性</strong></p>
<pre><code>不能访问子类的属性（可以考虑强制转换）
</code></pre></li>
<li><p><strong>多态的细节</strong></p>
<pre><code>动态绑定，在运行时根据对象的类型确定动态调用的方法
</code></pre></li>
</ol>
<h2 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h2><p> <strong>复合包括组合和聚合</strong></p>
<pre><code>has－a机制
组合和聚合表示将各个部分组合在一起，用于表达整体与部分的关系。在面向对象的编程思想里，就是用已有类的对象封装新的类。
</code></pre><ul>
<li>组合 ：表示一种<code>强的、严格的</code>整体与部分的关系，部分和整体的生命周期一样。 比如：人和人头</li>
<li>聚合 ：表示一种<code>弱的</code>整体与部分的关系，比如： 汽车和轮胎</li>
</ul>
<h2 id="Foundition框架"><a href="#Foundition框架" class="headerlink" title="Foundition框架"></a>Foundition框架</h2><pre><code>1. OC集合只能存储OC对象，不能存储c语言中的基本数据类型，如int，float，enum，struct，且不能在集合中存储nil。
</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ol>
<li>不可变字符串 ： NSString *string1;</li>
<li><p>可变字符串 ：  <code>NSMutableString</code> *string2;</p>
<p> 对可变字符串的操作：</p>
<p> 2.1 增加元素 </p>
<p> <code>string2 appendFormat:@&quot;hello&quot;];</code></p>
<p> 2.2 删除元素</p>
<p> <code>[string2 replaceCharacterInRange:NAMakeRange(2,3)];</code></p>
<p> 2.3 修改元素（替换）  </p>
<p> <code>[string2 replaceCharacterInRange:NAMakeRange(2,3)withString:@&quot;word&quot;];</code></p>
</li>
<li><p>字符串的操作</p>
<p> 3.1 比较</p>
<p> //判断两个字符串是否相等，返回的是BOOL值</p>
<p> <code>[str1 isEqualTo:str2];</code></p>
<p> <code>NSCompareResult res  = [str1 copmare:str2];</code></p>
<p> 不区分大小写的比较：<code>caseInsensitiveCompare</code></p>
<p> 有选择参数的比较： <code>［str compare：str2 option：NSStringCompareOption］</code></p>
<p> NSStringCompareOption选项可以传入的参数</p>
<pre><code>enum {
           NSCaseInsensitiveSearch = 1,   不区分大小写
           NSLiteralSearch = 2,           对于相等的字符串逐个比较
           NSBackwardsSearch = 4,         从后向前比较
          NSAnchoredSearch = 8,          限制比较从开始还是结尾
           NSNumericSearch = 64,          对于数字按数字比较
          NSDiacriticInsensitiveSearch = 128,     不区分音节
           NSWidthInsensitiveSearch = 256,         忽略full－width half－width （如 Unicode code point U+FF41 和 Unicode code point U+0061 的字母 “a”is equal）
           NSForcedOrderingSearch = 512,           对于不区分大小写比较相等的字符串，强制返回NSOderedAscending or NSOrderedDeascending （如“aa” is grater than “AA”）
           NSRegularExpressionSearch = 1024        treated as an ICU－compatible regular expression
    };
</code></pre><p> NSCompareResult 有三种值：</p>
<pre><code>NSOrderedSame  两字符串相等
NSOrderedAscending  str1 &lt; str2
NSOrderedDeascending  str1 &gt; str2;
</code></pre><p> 3.2 求长度</p>
<p> <code>NSUInteger strlen = [str1 length];</code></p>
<p> 3.3 大小写转换</p>
<p> <code>str2 = [str1 uupercaseString];</code></p>
<p> <code>str2 = [str1 lowercaseString];</code></p>
<p> 3.4 获取文件前缀、后缀</p>
<p> <code>str2 ＝[str1 hasPrefix:@&quot;word&quot;];</code></p>
<p> <code>str2 = [str1 hasSuffix:@&quot;txt&quot;];</code></p>
<p> 3.5 获取子串</p>
<p> //获取str2在str1中的位置，即range.location and range.length</p>
<p> <code>range = [str1 rangOfString:str3];</code></p>
<p> <code>range = [str1 rangOfString:@&quot;hello&quot;];</code></p>
<p> //获取str1 第6个位置之后的字符串赋值给str2</p>
<p> <code>str2 = [str1 substringFromIndex:6];</code></p>
<p> //获取str1 从开始到第6个位置之间的字符串赋值给str2</p>
<p> <code>str2 = [str1 substringTOIndex:6];</code></p>
<p> //获取str1 从第6个位置开始长度为5的字符串赋值给str2</p>
<p> <code>str2 = [str1 substringWithRange:NSMakeRange（6，7）];</code></p>
<p> 3.6 文件路径的转换</p>
<p> //间文件路径字符串str1 ＝ @“~/test.html”的路径转换为绝对路径赋值给str2</p>
<p> <code>str2 = [str1 stringByExpandingTildeInPath];</code></p>
<p> //间文件路径字符串str1 ＝ @“/users/qingyun/test.html”的路径转换为相对路径赋值给str2</p>
<p> <code>str2 = [str1 stringByAbbreviatingWithTildeInPath];</code></p>
<p> 3.7 文件路径的扩展名</p>
<p> <code>str2 = [str1 pathExtension];</code>   此时 str2 ＝ @“html”；</p>
<p> 3.7 删除文件路径的后缀</p>
<p> <code>str2 = [str1 stringByDeletePathExtension];</code>   此时 str2 ＝ @“~/test”；</p>
<p> 3.9 追加字符串</p>
<p> str1 ＝ @”hello word”;</p>
<p> <code>str2 = [str1 stringByAppendingFormat:@&quot;wellcom&quot;];</code>   此时 str2 ＝ @“hello word wellcom”;</p>
</li>
</ol>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol>
<li>不可变数组 ： NSArray  *array1;</li>
<li><p>可变数组 ： <code>NSMutableArray</code>  *array2;</p>
<p> 数组初始化：</p>
<p> <code>NSArray *array1 = [NSArray arrayWithObjects:@&quot;hello&quot;,@&quot;word&quot;,@&quot;two&quot;,nil];</code></p>
<p> <code>NSArray *array1 = @[@12,@34,@&quot;hello&quot;,@&quot;error&quot;];</code></p>
<p> //创建空数组</p>
<p> <code>NSMutableArray  *array2 = [NSMutableArray array];</code></p>
<p> //用已有的数组创建新数组</p>
<p> <code>NSMutableArray  *array2 = [NSMutableArray arrayWithArray:array];</code></p>
<p> //创建一个数组，并预分配内存</p>
<p> <code>NSMutableArray  *array2 = [NSMutableArray arrayWithCapacity:40];</code></p>
<p> 对可变数组的操作：</p>
<p> 2.1 增加元素 </p>
<p> <code>[array2 addObjects:@&quot;hello&quot;];</code></p>
<p> 2.2 删除元素</p>
<p> //删除下标为2的对象</p>
<p> <code>[array2 removeObjectsAtIndex:2];</code></p>
<p> //删除一定范围内的所有@“hello”</p>
<p> <code>[array2 removeObject:@&quot;hello&quot; inRange:NSMakeRange(2, 3)];</code></p>
<p> <code>[array3 removeObjectIdenticalTo:@&quot;is&quot; inRange:NSMakeRange(1, 5)];</code></p>
<p> //删除该数组内的所有@“hello”</p>
<p> <code>[array2 removeObjectIdenticalTo:@&quot;hello&quot;];</code></p>
<p> 2.3 修改元素（替换）</p>
<p> <code>[array2 removeObjectsAtIndex:2 withObject:@&quot;dog&quot;];</code></p>
<p> <code>[array2 removeObjectsAtIndex:2 withObject:str];</code></p>
<p> <code>[array2 removeObjectsInRange:NSMakeRang(0,2) withObjectFromArray:array];</code></p>
<p> 2.4 插入元素</p>
<p> <code>[array2 insertObjects:str1 AtIndex:2];</code></p>
<p> 2.5 访问数组某个对象</p>
<p> <code>array2［下标］</code></p>
</li>
</ol>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ol>
<li>不可变数组 ： NSDictionary  *dictionary1;</li>
<li><p>可变数组 ： <code>NSMutableDictionary</code>  *dictionary2;</p>
<p> 字典初始化：</p>
<p> <code>Dictionary *dictionary1 = [NSDictionary dictionaryWithObjectsAndKeys:str1,@&quot;hello&quot;,str2,@&quot;word&quot;,str3,@&quot;two&quot;,nil];</code></p>
<p> <code>Dictionary *dictionary1 = @{@&quot;num1&quot;:@12,@&quot;num2&quot;:@34,@&quot;str1&quot;:@&quot;hello&quot;,@&quot;str2&quot;:@&quot;error&quot;};</code></p>
<p> //创建空字典</p>
<p> <code>NSMutableDictionary  *dictionary2 = [NSMutableDictionary dictionary];</code></p>
<p> //用已有的字典创建新字典</p>
<p> <code>NSMutableDictionary  *dictionary2 = [NSMutableDictionary dictionaryWithDictionary:array];</code></p>
<p> //创建一个字典，并预分配内存</p>
<p> <code>NSMutableDictionary  *dictionary2 = [NSMutableDictionary dictionaryWithCapacity:40];</code></p>
<p> 对可变字典的操作：</p>
<p> 2.1 增加元素 </p>
<p> <code>[dictionary2 addObjects:(id)forKey:@&quot;key&quot;];</code></p>
<p> 2.2 删除元素</p>
<p> <code>[dictionary2 removeObjectForKey:@&quot;key&quot;];</code></p>
<p> 2.3 修改元素（替换）</p>
<p> <code>[dictionary2 setObject:（id）forKey:@&quot;key&quot;];</code></p>
<p> 2.4 访问字典</p>
<p> <code>dictionary2［@“key”］;</code></p>
<p> <code>[dictionary2 objectForKey:@&quot;key&quot;]</code></p>
</li>
</ol>
<h4 id="装箱－开箱"><a href="#装箱－开箱" class="headerlink" title="装箱－开箱"></a>装箱－开箱</h4><ol>
<li><p>对基本数据类型的装箱－NSNumber</p>
<p> //装箱方法1</p>
<p> <code>NSNumber *number = [NSNumber numberWithChar:&#39;X&#39;];</code></p>
<p> <code>NSNumber *number = [NSNumber numberWithINT:23];</code></p>
<p> <code>NSNumber *number = [NSNumber numberWithBOOL:YES];</code></p>
<p> <code>NSNumber *number = [NSNumber numberWithDouble:34.5];</code></p>
<p> //装箱方法2</p>
<p> @23，@34.5</p>
<p> //开箱</p>
<p> <code>[number charValue];</code></p>
<p> <code>[number intValue];</code></p>
<p> <code>[number BOOLValue];</code></p>
<p> <code>[number DoubleValue];</code>    </p>
</li>
<li><p>对所有非对象类型的装箱（包括基本数据类型）－ NSValue</p>
<p> //对NSRect，NSPoint，NSRange装箱,也可以对基本数据类型进行装箱</p>
<p> NSRect rect = NSMakeRect(10,20,30,40);</p>
<p> <code>NSValue *value = [NSvalue valueWithBytes:&amp;rect objCType:@encode(NSRect)];</code></p>
<p> int a ＝ 5；</p>
<p> <code>NSValue *value = [NSvalue valueWithBytes:&amp;a objCType:@encode(int)];</code></p>
<p> //开箱</p>
<p> NSRect rect2 ＝ ｛0｝；</p>
<p> <code>［value getValue:&amp;rect］;</code></p>
<p> int b = 0;</p>
<p> <code>[value getValue:&amp;b];</code></p>
<p> //仅对NSRect，NSPoint，NSRange装箱</p>
<p> <code>NSValue *value = [NSValue valueWithRect];</code></p>
<p> <code>NSValue *value = [NSValue valueWithRange];</code></p>
<p> <code>NSValue *value = [NSValue valueWithPoint];</code></p>
<p> //开箱</p>
<p> NSRect rect2 ＝ ｛0｝；</p>
<p> <code>[value rectValue];</code></p>
<p> NSRange range = {0};</p>
<p> <code>[value rangeValue];</code></p>
<p> NSPoint point = {0};</p>
<p> <code>[value pointValue];</code></p>
</li>
</ol>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><pre><code>//normal enumerator

NSEnumerator *enumer = [array objectEnumerator];

id obj;
while (obj = [enumer nextObject]) {
    NSLog(@&quot;%@&quot;,obj);
}

NSEnumerator *enumer2 = [array reverseObjectEnumerator];
while (obj = [enumer2 nextObject]) {
    NSLog(@&quot;%@&quot;,obj);
}

//fast enumerator

for (id obj2 in array) {
    NSLog(@&quot;%@&quot;,obj2);
}
</code></pre><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><ol>
<li><p>类别的简述</p>
<ul>
<li>为现有的类（自定义的类、第三方的类或者是系统定义的类）添加一些新的行为；</li>
<li>类别可以解决继承不能为累簇添加新方法的问题。</li>
</ul>
</li>
<li><p>类别的声明和实现</p>
<p> 格式： <code>类名 ＋ 类别名</code></p>
<p> 如：为NSString 创建一个类别 <code>NSString＋NumberConvenience</code>；</p>
<p> 只要保证类别名称唯一，可以向一个类中添加任意数量的类别。</p>
<p> 声明：</p>
<p> @interface NSString （NumberConvenience）</p>
<p> － （NSNumber *）lengthAsNumber;</p>
<p> @end</p>
<p> 实现：</p>
<p> @implementation NSString （NumberConvenience）</p>
<p> － （NSNumber *）lengthAsNumber<br> {</p>
<p> }</p>
<p> @end</p>
</li>
<li><p>类别的优缺点</p>
<p> 缺点：</p>
<pre><code>* 只能添加方法，只可以访问原始类的实例变量，无法向类别中添加新的实例变量
* 名称冲突。类别具有最高优先级，即当类别中定义与对应类中已有的方法同名的方法，对象调用该方法时，会优先调用类别中定义的方法。
* 多个Category中如果实现了相同的方法，只有最后一个参与编译的才会有效   
</code></pre><p> 优点：</p>
<pre><code>* 将类的实现代码分散到多个不同文件或框架中。
* 可以创建对类中私有方法的前向引用，
* 向对象添加非正式协议。
</code></pre></li>
<li><p>使用类别实现类的扩展</p>
<p>  类的扩展等同于在类声明的<code>源代码</code>中声明一个无名的（即括号“ （） ”里面为空）类别，并实现；</p>
<ul>
<li>类的扩展可以在<code>源代码</code>中使用</li>
<li>可以添加实例变量作为类的私有变量和方法</li>
<li>可以将只读权限改为读写权限</li>
<li>创建数量不限</li>
</ul>
</li>
<li><p>利用类别分散实现代码的优点</p>
<pre><code>. 在大型的项目中， 一个类的实现可能非常大，并且.m文件不能分离。但是使用类别可以将一个类的实现分散且有规律的组织在不同的文件中。还可以将一个类的实现分散到不同的框架中。 
. 编程人员可以更加容易阅读代码并实现多人合作编码
. 版本管理降低冲突
. 维护人员更容易理解代码
</code></pre></li>
<li><p>非常正式协议</p>
<p> 非正式协议就是为NSObject类创建一个类别；</p>
</li>
<li><p>响应选择器</p>
<ul>
<li><p>使用@selector()编译指令来指定选择器,圆括号里是具体的方法名。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">（有几个参数要有几个冒号“ : ”）</div><div class="line"> 如：</div><div class="line"> @selector(setEngine:)</div><div class="line"> @selector(setTire:atIndex:)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- 选择器的类型关键字:SEL
- \- (BOOL)respondsToSelector:(SEL)@Selector; 使用此方法可以判断某一对象是否可以执行指定的方法。 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QYStudent *student = [[QYStudent alloc]init];</div></pre></td></tr></table></figure>

如： 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[student respondToSelector:(SEL)@selector(study)]; //对对象student判断其是否有study这个方法，有的话返回值为YES，没有的话返回值为NO。</div></pre></td></tr></table></figure>
</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ol>
<li><p>基本用途</p>
<ul>
<li>可以用来声明一大堆方法（不能声明成员变量）</li>
<li>只要某个类遵守了这个协议，就相当于拥有这个协议中的所有方法声明</li>
<li>只要父类遵守了某个协议，就相当于子类也遵守了    </li>
</ul>
</li>
<li><p>格式<br> @protocol 协议名</p>
<p> 方法声明列表</p>
<p> @end</p>
<p> 某个类遵守某个协议</p>
<p> @interface 类名 : 父类名&lt;协议名&gt;</p>
<p> @end</p>
</li>
<li><p>关键字</p>
<p> 协议中有2个关键字可以控制方法是否要实现（默认是@required），在大多数情况下，用途在于程序员之间的交流</p>
<ul>
<li>@required: 该关键字以下且@optional关键字以上的方法必须要实现（若不实现，编译器会发出警告</li>
<li>@optional: 该关键字以下且@required关键字以上的方法可以选择性的实现</li>
</ul>
</li>
<li><p>协议遵守协议</p>
<ul>
<li><p>一个协议可以遵守其他多个协议，多个协议之间用逗号 , 隔开</p>
<ul>
<li>一个协议遵守了其他协议，就相当于拥有了其他协议中的方法声明</li>
</ul>
<p>@protocol 协议名称 &lt;协议1, 协议2&gt;</p>
<p>@end</p>
</li>
</ul>
</li>
<li><p>基协议</p>
<ul>
<li>NSObject是一个基类，最根本最基本的类，任何其他类最终都要继承它</li>
<li>其实还有一个协议，名字也叫NSObject，它是一个基协议，最根本最基本的协议</li>
<li>NSObject协议中声明很多最基本的方法，比如description、retain、release等</li>
<li>建议每个新的协议都要遵守NSObject协议</li>
</ul>
</li>
<li><p>定义变量时指定协议</p>
<p> // NSObject类型的对象，并且要遵守NSCopying协议</p>
<ul>
<li><p>NSObject<nscopying> *obj;</nscopying></p>
<p>// 任何OC对象，并且要遵守NSCoding协议</p>
</li>
<li><p>id<nscoding> obj2;</nscoding></p>
</li>
</ul>
</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>内存管理机制：引用计数</strong></p>
<ol>
<li><p>引用计数的计算</p>
<ul>
<li>alloc 、new 、copy(copy生成接收对象的一个副本) //使用这三个方法创建对象时，对象的引用计数器为1<ul>
<li>- (id) retain; //给对象发送retain消息后，对象的引用计数器加1</li>
<li>- (void) release; //给对像发送release消息后，对象的引用计数器减1</li>
<li>- (void)dealloc; //当一个对象的引用计数器变为0而即将被销毁时,Objective-C自动向对                             象发送一条dealloc消息，我们通常都会在自己的对象中重写dealloc方法</li>
<li>- (unsigned) retainCount;//获取当前对象的引用计数器的值</li>
</ul>
</li>
</ul>
</li>
<li><p>非ARC环境下内存的管理</p>
<p> 当某个对象被持有有，［对象名 retain］；<br> 当某个对象不再被持有时，［对象名 release］；</p>
</li>
<li><p>ARC环境下内存的管理</p>
<ul>
<li><p>规则</p>
<p>  只要还有一个强指针变量指向对象，对象就会保持在内存中</p>
</li>
<li><p>强引用，弱引用</p>
<p>  ➢    默认所有实例变量和局部变量都是Strong指针</p>
<p>  ➢    弱指针指向的对象被回收后，弱指针会自动变为nil指针，不会引发野指针错误。其修饰符号为__weak;</p>
</li>
<li><p>注意点</p>
<pre><code>➢    不能调用release、retain、autorelease、retainCount
</code></pre><p> ➢    可以重写dealloc，但是不能调用[super dealloc]</p>
<p> ➢    @property : 想长期拥有某个对象，应该用strong，其他对象用weak</p>
<p> ➢    其他基本数据类型依然用assign</p>
<p> ➢    两端互相引用时，一端用strong、一端用weak</p>
<ol>
<li>自动释放池</li>
</ol>
</li>
<li>自动释放池是一个存放实体的集合，这些实体可能是对象，这些对象能够被自动释放。</li>
<li><p>/ - (id) autorelease; //是NSObject类提供的方法，此方法在某一个预定的时候，向对象发送release消息，返回值是接收消息的对象。实际上当给一个对象发送autorelease消息的时候，就是将这个对象添加到的自动释放池(NSAutoreleasePool)中，当自动释放池销毁时，会向该池中的所有对象发送release消息。</p>
<p>如： - (NSString <em>) description<br>{<br>  NSString </em>desc;<br>   desc = [[NSString alloc] initWithFormat: @” I am %d years old”,29];<br>   return ([desc autorelease]);<br>}</p>
</li>
</ul>
</li>
<li><p>内存管理规则</p>
<ul>
<li>如果我使用了new , alloc 或者copy方法获得一个对象，则我必须释放或自释放该对象。</li>
<li>如果你对对象调用了retain消息，那么你必须负责释放(release)这个对象，保证retain和release的使用次数相等。</li>
</ul>
</li>
</ol>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><ol>
<li><p>浅拷贝（shallow copy）</p>
<p> 不会复制所引用的对象，新复制的对象只会指向现有的引用对象上。（引用计数加 1 ，地址不变）</p>
</li>
<li><p>深拷贝（deep copy）</p>
<p> 真正意义的复制概念。得到的结果是多个，而非只是对象的引用。（引用计数 不变 ，地址发生变化）</p>
</li>
<li><p>关键字</p>
<p> <code>copy</code>：对不可变的集合copy为浅拷贝，对可变的集合copy为深拷贝</p>
<p> <code>mutableCopy</code>：对可变的或不可变的集合mutableCopy都是深拷贝，但是对于集合内部对象的拷贝时浅拷贝。</p>
</li>
</ol>
<h2 id="BLOCK"><a href="#BLOCK" class="headerlink" title="BLOCK"></a>BLOCK</h2><ol>
<li><p>基本概念</p>
<p> 代码块本质上是和其他变量类似。不同的是，代码块存储的数据是一个函数体。使用代码块时，可以像调用其他标准函数一样，传入参数数，并得到返回值。    </p>
</li>
</ol>
<pre><code>* Block封装了一段代码,可以在任何时候执行
* Block可以作为函数参数或者函数的返回值，而其本身又可以带输入参数或返回值。
* 苹果官方建议尽量多用block。在多线程、异步任务、集合遍历、集合排序、动画转场用的很多
</code></pre><ol>
<li><p>定义</p>
<pre><code>int (^MySum)(int, int) = ^(int a, int b) {
return a+b;
};
</code></pre><p>定义了一个叫MySum的blocks对象，它带有两个int参数，返回int。等式右边就是blocks的具体实现</p>
</li>
<li><p>对变量的访问权限</p>
<ul>
<li>对全局变量具有读写权限 </li>
<li>对静态变量具有读写权限</li>
<li>对局部变量只有访问权限（可以用<code>__block</code>修饰局部变量，这样可以对其进行修改）</li>
</ul>
</li>
<li><p>与函数指针的对比</p>
<p> <strong>定义函数指针</strong><br> int (<em>p)(int,int);<br> <em>*定义Blocks</em></em><br> int (^Blocks)(int,int);</p>
<p> <strong>调用函数指针</strong><br> (<em>p)(10, 20);<br> <em>*调用Blocks</em></em><br> Blocks(10, 20);</p>
</li>
<li><p>typedef和赋值</p>
<ul>
<li><p>在声明的同时定义变量，然后赋值<br>int (^MySum)(int,int) = ^(int a,int b) {<br>return a + b;<br>};</p>
</li>
<li><p>也可先用typedef先声明类型，再定义变量进行赋值<br>typedef int (^MySum)(int,int);<br>MySum sum = ^(int a,int b) {<br>return a + b;<br>}; </p>
</li>
</ul>
</li>
</ol>
<h2 id="KVC（Key-Valuble-Coding）"><a href="#KVC（Key-Valuble-Coding）" class="headerlink" title="KVC（Key Valuble Coding）"></a>KVC（Key Valuble Coding）</h2><ol>
<li>基本概念<ul>
<li>是一种间接更改对象状态（或者说是属性值）的方式：key-value coding 简称KVC.</li>
<li>主要本质特点是采用字符串来标识对象的属性变量，并可以利用这个标识来更改对象的状态（或者说是属性值）</li>
</ul>
</li>
<li><p>基本用法</p>
<ul>
<li>/ - (id)valueForKey:(NSString *)key //以key作为标识符，获取其对应的属性值</li>
<li>/ - (void)setValue:(id)value forKey:(NSString *)key //以key作为标识符设置其对应的属性值。</li>
</ul>
</li>
<li><p>调用机制</p>
<ul>
<li>valueForKey:会首先查找以参数名命名（格式为-key或者isKey)的getter方法，如果找到的话则调用这个方法；如果没有找到这样的getter方法，它将会在对象内部寻找名称格式为_key或者key的实例变量，然后返回。</li>
<li>setValue:forKey:的机制跟valueForKey相似。它首先查找参数名命名的setter方法，如果找到的话则完成设置；如果没有找到setter方法， 则直接在类中找到名称格式为_key或者key的实例变量， 然后将value赋值给它。</li>
</ul>
</li>
<li><p>键路径</p>
<p>键路径的概念和表示：可以在对象和不同的变量名称之间用圆点分开来表示。</p>
<ul>
<li>-(id)valueForKeyPath:(NSString *)keyPath //以keyPath作为标识符，获取其对应的属性值</li>
<li>-(void)setValue:(id)value forKeyPath:(NSString *)keyPath //以keyPath为标识符，设置其对应的属性的值。</li>
</ul>
</li>
</ol>
<p>##通配符 《系统级别》</p>
<ol>
<li><p>{}</p>
<p> touch {1,2,3,4,6,a,c,b,hello,t}.c</p>
<p> // 同时创建 1.c,2.c,3.c,4.c,6.c,a.c,c.c,b.c,hello.c,t.c文件</p>
</li>
<li><p>*</p>
<p> ls *.c</p>
<p> //列出所有以 .c为后缀的文件</p>
</li>
<li><p>? </p>
<p> ls ??h*.c</p>
<p> //列出第三个字符为“h”，且以.c为后缀的所有文件</p>
</li>
<li><p>[]</p>
<p> ls [0-9].c</p>
<p> //列出以数字0-9为文件名的.c文件</p>
</li>
<li><p>!</p>
<p> ls ![0-9].c</p>
<p> //列出所有不是以数字0-9为文件名的.c文件</p>
</li>
</ol>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><ol>
<li><p>谓词的定义</p>
<p> 谓词使用了KVC机制。</p>
<p> <code>NSPredicate *predicate = [[NSPredicate prdicateWithFormat:@string]];</code></p>
<p> //实历化一个谓词对象.</p>
<p> <code>NSArray predicateArr = [对象名 filteredArrayUsingPredicate predicate];</code></p>
<p> //向对象发消息，过滤出满足谓词条件的内容，并存放到数组predicateArr中；   （filteredArrayPredicate:NSPredicate <em> 方法的返回值时NSArray </em>类型）</p>
</li>
<li><p>谓词中的操作符</p>
<p>  <em>谓词操作符不区分大小写</em></p>
<ul>
<li><p>关系运算符</p>
<p>  <code>{ &gt; &lt; &gt;= &lt;= == != }</code></p>
</li>
<li><p>逻辑运算符 </p>
<p>  <code>{&amp;&amp;(and) ||(or) !}</code></p>
</li>
</ul>
</li>
</ol>
<pre><code>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;name != &apos;lisi&apos; and age &gt; 12&quot;];</div></pre></td></tr></table></figure>


* 范围运算符

    `{between in}`

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">predicate = [NSPredicate predicateWithFormat:@&quot;age in &#123;23,25&#125;&quot;];</div><div class="line">//仅仅过滤出 age ＝ 23 和 age ＝ 25 的信息</div><div class="line">predicate = [NSPredicate predicateWithFormat:@&quot;age between &#123;23,25&#125;&quot;];</div><div class="line">//过滤出 23 &gt;= age &lt;＝ 25 的信息</div></pre></td></tr></table></figure>

* 通配符

    `{* ? 主要与like一起使用}`

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">predicate = [NSPredicate predicateWithFormat:@&quot;name like &apos;??a*&apos;&quot;];</div><div class="line">//过滤name第三个字母为a的信息</div></pre></td></tr></table></figure>


* 字符串特有操作符

    `｛contains like endswith beginswith ［c］不区分大小写［d］不区分音节［cd］｝`

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">predicate = [NSPredicate predicateWithFormat:@&quot;name endswith[cd] &apos;u&apos; and name contains[cd] &apos;ao&apos;&quot;];</div><div class="line">//过滤name以‘u’结尾 且 包含 “ao”的信息</div></pre></td></tr></table></figure>

* 集合中的操作符

    `{ANY ALL}`

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">predicate = [NSPredicate predicateWithFormat:@&quot;ALL age &gt; 10&quot;];</div><div class="line">      if ([predicate evaluateWithObject:Arr]) &#123;</div><div class="line">          NSLog(@&quot;evaluable&quot;);</div><div class="line">      &#125;else &#123;</div><div class="line">          NSLog(@&quot;It&apos;s  not evaluable &quot;);</div><div class="line">      &#125;</div><div class="line">      //判断数组Arr中的对象中age是否全部大于10</div></pre></td></tr></table></figure>


* 谓词模板

    `{$  %K}`

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age between $RANGE&quot;];</div><div class="line">      NSArray *arr = @[@20,@50];</div><div class="line">      NSDictionary *dic = @&#123;@&quot;RANGE&quot;:arr&#125;;</div><div class="line">      //过滤 20 &gt;= age &lt;= 50的信息</div><div class="line">      </div><div class="line">      NSString *keyPath = @&quot;age&quot;;</div><div class="line">      predicate = [NSPredicate predicateWithFormat:@&quot;%K &gt; %@&quot;,keyPath,@20];</div><div class="line">      //过滤age &gt; 20 的信息</div></pre></td></tr></table></figure>
</code></pre><h2 id="正则表达式-《工具级别》"><a href="#正则表达式-《工具级别》" class="headerlink" title="正则表达式 《工具级别》"></a>正则表达式 《工具级别》</h2><p><strong>选择</strong></p>
<p>| 竖直分隔符代表选择。例如，“grey | gray”可以匹配grey或gray</p>
<p><strong>数量限定</strong></p>
<ul>
<li>+号代前面的字符至少要出现一次，可以出现多次。例如，“goo + gle”可以匹配google,gooogle,goooogle等</li>
<li>？号代表前面的字符最多只能出现一次，可以不出现。例如，“colour？r”可以匹配color或者colour</li>
<li><em>星号代表前面的字符可以不出现，可以出现一次或多次。例如，”0\</em>42”匹配42，042，0042，0004等。</li>
<li>“{n}”代表前面的字符要出现n次，“{2，6}”代表前面的字符可以选择性的出现2-6次，例如，”go{2}gle”可以匹配google</li>
</ul>
<p><strong>匹配</strong><br>“（）”圆括号可以用来定义操作符的范围和优先度。例如，“gr(a|e)y”等价与“gray|grey”,”(grand)?father” 可以匹配father和grandfather。</p>
<p><strong>^ $符号</strong></p>
<ul>
<li>^符号代表开始，例如，“^b”可以匹配以字符b开始的一类字符串</li>
<li>$符号代表结束，例如，“x$”可以匹配以字符x结束的一类字符串，“^$”代表空</li>
</ul>
<p><strong>.符号</strong><br> .点符号，代表可以是任意字符。例如，“^a.{3}[0-9]+eh(hello)$”可以匹配ad_dehhello,a23d4ehhello,asdf345ehhello等</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">以上规则可以综合使用</div></pre></td></tr></table></figure>
<h4 id="正则表达式可以用在grep，awk，sed，gas，find，等命令中，"><a href="#正则表达式可以用在grep，awk，sed，gas，find，等命令中，" class="headerlink" title="正则表达式可以用在grep，awk，sed，gas，find，等命令中，"></a>正则表达式可以用在grep，awk，sed，gas，find，等命令中，</h4><ul>
<li>grep | ‘[a-z]{5}zsh$’ dotfiles 过滤dotifiles目录下的所有文件及目录</li>
<li>ls | grep ‘^d’ ls命令列出当前目录下的以d开头的文件包括目录</li>
<li>grep | -R ‘hello’ ./* 递归的查看根路径下的所有包含hello字符串的内容（-RE 递归的查找，支持正则表达式）</li>
<li>find . -name ‘hello’查看名字为hello的文件的路径，</li>
<li>find . -type d 查看当前目录下的所有文件夹的路径</li>
<li>sed -RE ‘/^_.*(false)$/‘ /etc/passwd 查看passwd文件内容不是以下划线开始且以false结束的内容</li>
</ul>
<p><img src="http://s11.sinaimg.cn/middle/5f764369naf040c6ee03a&amp;690" alt="image"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oc/">oc</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/10/23/OC笔记/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-cocoa内存管理" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/20/cocoa内存管理/">cocoa内存管理</a>
    </h1>
  

        <a href="/2014/10/20/cocoa内存管理/" class="archive-article-date">
  	<time datetime="2014-10-20T14:02:53.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-10-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##引用计数的概念<br><code>以办公室开灯关灯举例</code></p>
<p>##内存管理的思考方式</p>
<p>###自己⽣成的对象,自己持有 </p>
<pre><code>    * alloc
    * mutableCopy
    ￼* new
    ￼* copy

自⼰生成并持有对象
id obj = [[NSObject alloc] init];
￼￼
</code></pre><p>###非自己生成的对象,自己也能持有<br>￼￼</p>
<pre><code>取得非⾃⼰⽣成的对象但⾃⼰不持有对象 id obj =  [NSMutableArray array];
￼￼
取得⾮自⼰⽣成的对象但⾃己持有对象 id obj = [NSMutableArray array];
⾃己持有对象 [obj retain];
</code></pre><p>￼￼<br>￼</p>
<p>###不再需要自己持有的对象时释放<br>            ￼￼￼ ⾃⼰⽣成并持有对象<br>            id obj = [[NSObject alloc] init];</p>
<pre><code>⼀一般会在release之后,将对象指针赋为nil,以避免指针悬空的情况       obj = nil;


￼释放对象
￼[obj release];

取得非⾃己⽣成的对象但⾃⼰持有对象 

id obj = [NSMutableArray array];


￼￼⾃⼰持有对象
￼[obj retain];


￼释放对象
￼[obj release];
￼obj = nil;
￼
</code></pre><p>###非自己持有的对象无法释放<br>￼￼<br>            ￼自己生成并持有对象<br>            id obj = [[NSObject alloc] init];</p>
<pre><code>/释放之后再次释放已⾮自己持有的对象,应⽤用程序会崩溃 [obj release];


￼ 释放对象
￼[j release];


￼⼀一般会在release之后,将对象指针赋为nil,以避免指针悬空的情况
￼ obj = nil;
￼
￼ 取得非自己生成的对象且自己不持有该对象 

id obj = [NSMutableArray array];


 释放了⾮⾃己持有的对象,会导致应用程序崩溃 

 [obj release];
</code></pre><p>￼<br>￼<br>￼<br>            ￼ ⾃⼰生成并持有对象<br>            id obj = [[NSObject alloc] init];</p>
<pre><code> ⼀一般会在release之后,将对象指针赋为nil,以避免指针悬空的情况 

 obj = nil;


￼释放对象
￼[obj release];
</code></pre><p>￼</p>
<p>##ARC规则 </p>
<p>###所有权修饰符</p>
<pre><code>__strong修饰符    
￼__weak 修饰符
￼__unsafe_unretained修饰符
__autoreleasing
</code></pre><p><strong>__strong 修饰符</strong></p>
<blockquote>
<p>__strong修饰符表示对象的“强引用”。持有强引用的变量在超出其作用域时被废弃,随着强引用的失效,引⽤的对象会随之释放。 <code>Demo</code></p>
</blockquote>
<p><em>__strong修饰符修饰的变量,不仅只在变量作⽤域中,在赋值上也能正确地管理其对象的所有者。 <code>Demo</code></em></p>
<p><em><strong>strong修饰符同后面要讲的_weak修饰符和</strong>autoreleasing修饰符⼀一起,可以保证将附有这些修饰符的自动变量初始化为nil。 <code>Demo</code></em></p>
<blockquote>
<p>__weak 修饰符</p>
</blockquote>
<p><em>循环引用容易发⽣内存泄露。所谓内存泄露就是应当废弃的对象在超出其生存周期后继续存在。 Demo __weak修饰符在持有某对象的弱引用时,若该对象被废弃,则此弱引用将⾃动失效且处于nil被赋值的状态(空弱引用) <code>Demo</code>
</em></p>
<blockquote>
<p>__unsafe_unretained 修饰符</p>
</blockquote>
<p><em>附有<strong>unsafe_unretained 修饰符的变量不属于编译器的内存管理对象 <code>Demo</code> 赋值给附有</strong>unsafe_unretained修饰符变量的对象在通过该变量使用时,如果没 有确保其确实存在,那么应用程序就会崩溃 <code>Demo</code>
</em></p>
<blockquote>
<p>__autoreleasing 修饰符</p>
</blockquote>
<p>￼￼*在使⽤ARC时,不能使用autorelease⽅方法,也不能使用NSAutoreleasePool类 </p>
<p>指定”@autoreleasepool块”来替代”NSAutoreleasePool”类对象生成、持有以及废弃这⼀范围 </p>
<p>另外,要通过将对象赋值给附加了__autoreleasing修饰符的变量来替代调用autorelease⽅方法 <code>Demo</code>*</p>
<p>#####显式的附加autoreleasing修饰符同显式地附加strong修饰符一样罕见,原因如下: </p>
<p>( <code>考虑两种使用autoreleasepool的场景</code> )</p>
<p><strong>非自己生成并持有的对象</strong>:</p>
<pre><code>编译器会检查方法名是否以alloc/new/copy/mytableCopy开始,

如果不是就说明是⾮自己生成并持有的对象,

编译器会自动将返回的对象注册到autoreleasepool中
</code></pre><p><strong>￼￼自己生成并持有的对象,在函数中返回时:</strong></p>
<pre><code>由于return使得对象变量超出其作用域,

所以强引⽤对应的⾃己⽣成并持有的对象会被自动释放,

但该对象如果作为函数的返回值,

编译器会自动将其注册到autoreleasepool中
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理/">内存管理</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/10/20/cocoa内存管理/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-hexo搭建" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/20/hexo搭建/">hexo搭建</a>
    </h1>
  

        <a href="/2014/10/20/hexo搭建/" class="archive-article-date">
  	<time datetime="2014-10-20T13:37:23.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-10-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://www.zkedu.com/images/upfiles/2014/02/14/20140214560901-387.jpg" alt="mou icon"></p>
<p>1.安装nvm(node.js的版本管理工具）</p>
<pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh
</code></pre><p>2.添加如下内容到.zshrc配置文件</p>
<pre><code>[ -s &quot;/Users/`users`/.nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/Users/`users`/.nvm/nvm.sh&quot; # This loads nvm
</code></pre><p>3.安装node.js(通过nvm安装)</p>
<pre><code>$ nvm install 0.10
</code></pre><p>4.安装hexo（通过npm安装）</p>
<pre><code>$ npm install -g hexo
</code></pre><p>5.创建hexo文件夹，并安装hexo相关组件</p>
<pre><code>$ hexo init hexo
$ cd hexo
$ npm install
</code></pre><p>6.本地查看</p>
<p>输入如下命令后，打开浏览器，并输入localhost:4000来查看</p>
<pre><code>$ hexo g
$ hexo s
</code></pre><p>7.注册github账号</p>
<pre><code>创建github账号同名repository
eg:github账号名位dorayox，则创建dorayox.github.io
部署到github上
</code></pre><p>8.如下所示编辑_config.yml</p>
<pre><code>deploy:
  type: github
  repository: git@github.com:dorayox/dorayox.github.io.git
  branch: master
</code></pre><p>9.输入如下命令，完成到github得部署，之后打开浏览器并输入dorayox.github.io来查看</p>
<pre><code>$ hexo g
$ hexo d
</code></pre><blockquote>
<p>若hexo仍不能用则进行下面操作：</p>
</blockquote>
<ol>
<li><p>检查 ～ 目录下 <code>.nvm</code> 是否 git 化，若是则删除其中 <code>.git</code> 删除，</p>
</li>
<li><p>进入 <code>.nvm/v0.10.32/bin</code> 目录下复制 <code>Users/qingyun/.nvm/v0.10.32/bin</code> 目录，</p>
</li>
<li><p>再次进入 ～目录下，<code>vi .zshrc</code><br>设置路径   <code>export PATH=$PATH:/Users/qingyun/.nvm/v0.10.32/bin</code> </p>
</li>
<li><p>退出iterm重新进入，<code>cd hexo</code> ，</p>
</li>
<li><p>再次运行hexo命令如：<code>hexo s</code> </p>
</li>
</ol>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mac上搭建hexo极简指南/">Mac上搭建hexo极简指南</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/10/20/hexo搭建/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-vim使用" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/20/vim使用/">vim使用</a>
    </h1>
  

        <a href="/2014/10/20/vim使用/" class="archive-article-date">
  	<time datetime="2014-10-20T13:00:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-10-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>vim编辑器使用 </p>
</li>
<li><p>C语言函数</p>
<pre><code>函数定义         函数声明         函数嵌套(new)
</code></pre></li>
<li><p>gcc编译器</p>
<pre><code>预处理 gcc -E 编译 gcc -S 汇编 gcc -c 链接
调试 gcc -g 指定输出名字 gcc -o 开启警告提醒 gcc -Wall
</code></pre></li>
<li><p>lldb调试器</p>
<pre><code>list (l)
break (b) run (r)
next (n) step (s) continue (c) quit (q)
</code></pre></li>
<li><p>unix/linux常用符号</p>
</li>
</ol>
<pre><code>^
$
&gt;
&lt;
! (!!、!gcc) ? ($?)
</code></pre><ol>
<li><p>unix/linux常用命令 cd</p>
<pre><code>ls pwd cat cp mv mkdir touch echo
</code></pre></li>
<li><p>unix/linux的环境变量<br>￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$HOME	$PATH</div></pre></td></tr></table></figure>
<p>###sizeof运算符详解</p>
<pre><code>1. sizeof(char)
2. sizeof(short) 3. sizeof(int)
4. sizeof(long)
5. sizeof(float)
6. sizeof(double) 7. sizeof(char *) 8. sizeof(int *)
9. sizeof(array) 
</code></pre><p>###字符串操作</p>
<pre><code>1. atoi/atol(将字符转换成整数)
2. strtod/strtol (将字符串转换成小数)
3. tolower/toupper (大小写字母转换)
 man ctype - man tolower 
4. strcmp/strcasecmp(字符串比较)
5. strchr/strstr
6. strcpy/strncpy
7. strcat/strncat
8. strlen
</code></pre><p>###内存操作</p>
<pre><code>1. malloc - free 2. memset
3. memcpy
4. memcmp
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim的使用/">vim的使用</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/10/20/vim使用/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Git-操作" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/20/Git-操作/">Git 操作</a>
    </h1>
  

        <a href="/2014/10/20/Git-操作/" class="archive-article-date">
  	<time datetime="2014-10-20T11:33:41.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-10-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git-操作"><a href="#Git-操作" class="headerlink" title="Git 操作"></a>Git 操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol>
<li><p>初始化仓库</p>
<p>   。git init</p>
</li>
<li><p>配置作者信息</p>
<p>   。git config –global user.email”youremail@corp.com”</p>
<p>   。git config –global user.email”youremail@corp.com”</p>
</li>
</ol>
<ol>
<li><p>添加文件到暂存区</p>
<p>  。git add <filename><br>  。git add * (添加所有文件到暂存区)</filename></p>
</li>
<li><p>移除文件</p>
<p>  。git rm <filename></filename></p>
</li>
<li><p>重命名一个文件</p>
<p>  。 git rm <filename></filename></p>
</li>
<li><p>提交暂存区</p>
<p>  。 git commit只会提交暂存区(staged)⾥面的⽂件</p>
<p>  。 git commit -m “message”</p>
</li>
<li><p>查看工作目录的状态</p>
<p>  。 git status</p>
</li>
<li><p>查看提交历史记录</p>
<p>  。 git clone</p>
</li>
<li><p>查看文件改变</p>
<p>  。 git diff</p>
</li>
</ol>
<hr>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><ol>
<li><p>撤销加入暂存区的操作</p>
<p> 。git reset HEAD \<file></file></p>
</li>
</ol>
<ol>
<li><p>撤销修改的操作</p>
<p> 。git checkout – \<file></file></p>
</li>
<li><p>将本地的修改放进回收站 </p>
<p> 。git stash</p>
</li>
<li><p>从回收站中恢复本地的修改 </p>
<p> 。git stash apply</p>
</li>
</ol>
<p>￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼</p>
<h2 id="￼Tag操作"><a href="#￼Tag操作" class="headerlink" title="￼Tag操作"></a>￼Tag操作</h2><ol>
<li><p>查看tag</p>
<p> 。git tag</p>
</li>
<li><p>创建tag</p>
<p> 。git tag -a v1.0 -m “my version 1.0”</p>
</li>
<li><p>显示tag信息</p>
<p> 。git show v1.0</p>
</li>
<li><p>对之前的提交打tag</p>
<p> 。git tag -a v0.1 -m “version 0.1”</p>
</li>
</ol>
<p>分支操作</p>
<ol>
<li><p>查看分支</p>
<p> 。git branch</p>
</li>
<li><p>创建分支</p>
<p> 。git branch <branchname></branchname></p>
</li>
<li><p>删除分支</p>
<p> 。git branch -d <branchname></branchname></p>
</li>
<li><p>切换分支</p>
<p> 。git checkout <branchname></branchname></p>
</li>
<li><p>合并分支</p>
<p> 。git merge <branchname></branchname></p>
</li>
<li><p>rebase操作</p>
<p> 。git rebase <basebranch> <newbranch></newbranch></basebranch></p>
</li>
</ol>
<h2 id="远端仓库操作"><a href="#远端仓库操作" class="headerlink" title="远端仓库操作"></a>远端仓库操作</h2><ol>
<li><p>克隆一个远端仓库</p>
<p> 。git clone URL</p>
</li>
<li><p>添加远端仓库</p>
<p> 。git remote add <name> <url></url></name></p>
</li>
<li><p>更新远端仓库的分支和数据 </p>
<p> 。git fetch <name></name></p>
</li>
<li><p>获取并合并远端仓库的分支到当前分支</p>
<p> 。git pull <reponame> <branchname></branchname></reponame></p>
<p> 。eg: git pull origin master </p>
</li>
<li><p>上传本地分支和数据到远端仓库</p>
<p> 。git push <reponame> <branchname></branchname></reponame></p>
<p> 。eg: git push origin master </p>
</li>
<li><p>跟踪远端仓库上的分支</p>
<p> 。git checkout –track origin/testbranch</p>
<p> 。git checkout -b test origin/testbranch<br>￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼<br>￼     </p>
</li>
</ol>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git-操作/">Git 操作</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/10/20/Git-操作/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Xcode常用命令" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/20/Xcode常用命令/">accelerator-key</a>
    </h1>
  

        <a href="/2014/10/20/Xcode常用命令/" class="archive-article-date">
  	<time datetime="2014-10-20T11:06:05.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-10-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://i.k1982.com/png/up/200712/20071206130310888.png" alt="image"></p>
<h2 id="Base-Key"><a href="#Base-Key" class="headerlink" title="Base Key"></a>Base Key</h2><p>command + c : 复制选中的内容</p>
<p>command + v : 粘贴已复制的内容</p>
<p>command + X : 剪贴已选中的内容</p>
<p>command + z : 撤销最近一次执行放入操作</p>
<p>command + / : 选中多行，一次注释多行</p>
<h2 id="Move-Key"><a href="#Move-Key" class="headerlink" title="Move Key"></a>Move Key</h2><p>ctrl + a : 移动光标到行首</p>
<p>ctrl + e : 移动光标到行尾</p>
<p>ctrl + p : 向上移动光标</p>
<p>ctrl + n : 向下移动光标</p>
<p>ctrl + b : 向左按字符移动光标</p>
<p>ctrl + f : 向右按字符移动光标</p>
<p>ctrl + option + b :  向左按符移动光标</p>
<p>ctrl + option + f :  向右按符移动光标</p>
<h2 id="Select-Key"><a href="#Select-Key" class="headerlink" title="Select Key"></a>Select Key</h2><p>ctrl + shift + b : 从光标处向左按字符选中</p>
<p>ctrl + shift + f : 从光标处向右按字符选中</p>
<p>ctrl + shift + p : 从光标处向上按行选中</p>
<p>ctrl + shift + n : 从光标处按行向上选中</p>
<h2 id="Delete-Key"><a href="#Delete-Key" class="headerlink" title="Delete Key"></a>Delete Key</h2><p>ctrl + d : 删除贯标右边的字符，按字符删除</p>
<p>ctrl + h : 删除贯标左边的字符，按字符删除</p>
<p>ctrl + k : 删除光标所在位置之后的所有内容</p>
<h2 id="Key-–-XCode"><a href="#Key-–-XCode" class="headerlink" title="Key – XCode"></a>Key – XCode</h2><p>command + shift + 0 :  打开官方文档</p>
<p>command + shift + n : 创建一个工程</p>
<p>commanf + n : 创建一个类、协议、类别、累扩展等</p>
<p>command + b : 编译代码</p>
<p>command + r : 运行生成的代码</p>
<p>command + shift + k : 清空XCode之前的编译</p>
<p>command + shift + -&gt;/&lt;-;(左方向键) : 切换页面</p>
<p>commang + f : 在官方文档中调出搜索栏</p>
<p>comand + option + enter : 分栏</p>
<p>command + enter  : 回到一栏</p>
<p>command + ctrl +左右键 : 不同页面的切换</p>
<p>shift + tab : 选中上一个</p>
<p>tab : 选中下一个</p>
<h2 id="other-key"><a href="#other-key" class="headerlink" title="other key"></a>other key</h2><p>command + ctrl + f  : 切换当前应用程序界面的大小，同时将桌面背景消失，只显示当前应用程序</p>
<p>command + option + “+” : vim终端界面的大小切换 </p>
<p>ctrl + 左右键 : 桌面快速切换</p>
<p>ctrl + 上键 : 已开应用程序，分布呈现在当前桌面</p>
<p>ctrl + 下键 : 呈现当前应用程序已开启的所有窗口，以及使用当前应用程序开启的历史文件</p>
<p>command + tab : 快速向后选择桌面已开启的应用程序</p>
<p>command + tab + shift : 快速向前选择桌面已开启的应用程序</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/accelerator-key/">accelerator-key</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/10/20/Xcode常用命令/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-xml笔记" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/21/xml笔记/">xml笔记</a>
    </h1>
  

        <a href="/2014/09/21/xml笔记/" class="archive-article-date">
  	<time datetime="2014-09-21T08:51:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-09-21</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#XML<br>1.什么是XML？    </p>
<p>XML：Extensible Markup Language(可扩展标记语言）   </p>
<ul>
<li>传输数据而非显示数据  (区别于HTML) </li>
<li>标签没有没预定，需要自行定义标签，具有自我描述性   </li>
<li>被设计为传输和存储数据，焦点是数据的内容   </li>
</ul>
<p>2.XML的特点？    </p>
<ul>
<li>仅仅是纯文本   </li>
<li>可以发明自己的标签   </li>
</ul>
<p>3.XML的优点？    </p>
<ul>
<li>简化数据共享   </li>
<li>简化数据传输*  </li>
<li>简化平台变更   </li>
<li>使数据更有用：独立于硬件、软件及应用程序</li>
</ul>
<p>4.树结构？（重点）    </p>
<pre><code>例子：
&lt;bookstore&gt;
&lt;book category=&quot;COOKING&quot;&gt;
 &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; 
 &lt;author&gt;Giada De Laurentiis&lt;/author&gt; 
 &lt;year&gt;2005&lt;/year&gt; 
 &lt;price&gt;30.00&lt;/price&gt; 
&lt;/book&gt;
&lt;book category=&quot;CHILDREN&quot;&gt;
 &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; 
 &lt;author&gt;J K. Rowling&lt;/author&gt; 
 &lt;year&gt;2005&lt;/year&gt; 
 &lt;price&gt;29.99&lt;/price&gt; 
&lt;/book&gt;
&lt;book category=&quot;WEB&quot;&gt;
 &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; 
 &lt;author&gt;Erik T. Ray&lt;/author&gt; 
 &lt;year&gt;2003&lt;/year&gt; 
 &lt;price&gt;39.95&lt;/price&gt; 
&lt;/book&gt;
&lt;/bookstore&gt;   
</code></pre><p>注释：例子中的根元素是 bookstore。文档中的所有book元素都被包含在 bookstore 中。   </p>
<pre><code>* 创建xml文件与plist文件一样，将后缀改为xml;
</code></pre><p>5.语法规则    </p>
<pre><code>*XML必须有根元素   
*XML必须有关闭标签   
*XML标签对大小写敏感
*XML元素必须被正确嵌套 
*属性必须加双引号
</code></pre><p>6.XML解析 (NSXMLParser解析方法)<br>*SAX: （！！只能读不能修改，解析速度快）    </p>
<ul>
<li>1）SAX（Simple APIs for XML），典型特点是：事件驱动，实现对XML的解析   </li>
<li>2）对文档的解析   </li>
<li>3）顺序访问机制，不能倒回去重新处理 </li>
<li></li>
<li>DOM：（！！不仅能读，还能修改，解析速度慢）   </li>
<li><p>DOM （Document Object Model，文档对象模型）定义了访问和操作文档的标准方法。<br>*1） 数结构   </p>
<p><em>*区别：SAX：遇到根元素进行初始化，顺序读下去，每读一行解析一行，基于事件的，    消耗内存比较小；<br>DOM：一次性把文件读入内存，我们可以读任意一个节点或者属性，消耗内存较大；一般用于服务器中
</em>苹果内部用的是SAX </p>
<hr>
</li>
</ul>
<p>7.常用解析框架 (常用) </p>
<p>   1)SAX::NSXMLParser 这是一个SAX方式解析XML的类库，默认包含在             iOS SDK中，使用也比较简单。   </p>
<p>   2)DOM::<1>GDataXML，<a href="http://code.google.com/p/gdata-" target="_blank" rel="external">http://code.google.com/p/gdata-</a>        objectivec-client/source/browse/trunk/Source/        <2>XMLSupport/，这是一套Google开发的DOM方式XML解析类库，支持读        取和修改XML文档，支持XPath方式查询。<br>   3)libxml2:同时支持SAX 和DOM</2></1></p>
<p> **#：解析步骤：<br> 1&gt;.对于SAX：   </p>
<ul>
<li><p>获取XML文件的路径  </p>
</li>
<li><p>根据URL 来创建XML的解析器NSParser对象  </p>
</li>
<li><p>设置XML解析器的代理（用代理方法解析）</p>
</li>
<li><p>开始解析    </p>
</li>
</ul>
<p> 2&gt;.对于DOM：（用GDataXML第三方库）   </p>
<ul>
<li>获取XML文件的路径或者URL</li>
<li>根据URL路径，把文件读入内存中（NSData对象：data）</li>
<li>通过data对象创建DataXMLDocument （doc）对象</li>
<li>取出XML的根元素（[doc rootElement]方法）;</li>
<li>由于doc在内存中是树形结构，可以根据子元素的名字取出所有该子元素<br>  的子元素      </li>
<li><p>遍历所有子元素，依次解析出子元素的属性和文本内容   </p>
<ul>
<li>for (GDataXMLElement *element in elements)    </li>
<li>[element attributeForName:kCategory]方法   </li>
</ul>
</li>
</ul>
<p>##JSON      </p>
<p>1.JSON定义和特点：   </p>
<ul>
<li>JSON （JavaScript Object Notation） JavaScript 对象表示法   </li>
<li>JSON 是轻量级的文本数据交换格式      </li>
<li>JSON 独立于语言   </li>
<li>JSON 具有自我描述性，更易理解   </li>
</ul>
<p>2.JSON格式：（数组或者字典）   </p>
<pre><code>[  

 {   

  &quot;name&quot;: &quot;zhangsan&quot;,   

 &quot;age&quot;: 30,   

 &quot;phone&quot;: [   

       &quot;123456&quot;,   

       &quot;654321&quot;   

       ],   

 &quot;address&quot;: {   

 &quot;country&quot;: &quot;china&quot;,   

 &quot;province&quot;: &quot;henan&quot;   

 },   

 &quot;married&quot;: false   

 },   

 {   

 &quot;name&quot;: &quot;lisi&quot;,   

 &quot;age&quot;: 40,   

&quot;phone&quot;: [   

       &quot;123456&quot;,   

       &quot;654321&quot;   

       ],   

&quot;address&quot;: {   

&quot;country&quot;: &quot;china&quot;,   

&quot;province&quot;: &quot;henan&quot;   

},   

&quot;married&quot;: false   

}   

]  

##*** array 中可以放置的value类型：
                    string,number ,object ,array ,true ,false ,null  
</code></pre><p>3.JSON解析步骤   </p>
<ul>
<li>取出文件URL   </li>
<li>创建data   </li>
<li>使用NSJSONSeriazilation 来解析data(接收用数组还是字典根据文件    而定)</li>
<li>一个一个元素解析，或者用字典遍历   </li>
</ul>
<p>4.JSON有用的网站   </p>
<ul>
<li>JSON格式校验网站：<a href="http://jsonlint.com" target="_blank" rel="external">http://jsonlint.com</a>    </li>
<li>www.json.org    </li>
<li>www.bejson.com (格式校验，开放接口等)   </li>
</ul>
<p>5.json 的解析框架：JSONKit（不常用，版本较低） 和 NSJSONSeriazilation（系统的，主流的）  </p>
<ul>
<li>www.json.org 网址上打开JSONKit选项然后复制网址，执行  git clone <a href="https://github.com/johnezang/JSONKit.git">https://github.com/johnezang/JSONKit.git</a> (复制的网址)</li>
</ul>
<p>##第三方库的应用   </p>
<ul>
<li>添加库：Building setting –&gt;搜索include /Header     Search …选项，双击添加提示的库路径    </li>
<li>链接：Building setting –&gt;搜索link/Other linker     flags … 选项–&gt; 双击添加链接   </li>
<li>编译ARC和非ARC ：Building phase –&gt;找到Compile Source …选项 –&gt;在非ARC得文件后面添加“-fno-objc-arc ” </li>
</ul>
<p>#JSON与XML解析程序：</p>
<ul>
<li>1.URL-&gt;NSRequest</li>
<li><p>2.[NSURLConnection sendAsynchronousRequest:request     queue:[[NSOperationQueue alloc] init]             completionHandler:^(NSURLResponse <em>response, NSData     </em>data, NSError *connectionError) {  </p>
<pre><code> 1&gt;JSON步骤如下:

// 反序列化
NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:0 error:NULL];

// 建立数组
NSMutableArray *arrayM = [NSMutableArray array];

[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    Video *v = [[Video alloc] init];

    [v setValuesForKeysWithDictionary:obj];

    [arrayM addObject:v];
}];

dispatch_async(dispatch_get_main_queue(), ^{
    self.videoList = [arrayM copy];

    [self.refreshControl endRefreshing];
  }); 
</code></pre></li>
</ul>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  2) XML步骤：   </div><div class="line">      </div><div class="line"> //1&gt;</div><div class="line">      NSXMLParser *parser = [[NSXMLParser alloc] initWithData:data];</div><div class="line">      </div><div class="line">// 2&gt; 设置代理</div><div class="line">      parser.delegate = self;</div><div class="line">      </div><div class="line">//3&gt; 开始解析</div><div class="line">      [parser parse];</div></pre></td></tr></table></figure>
<p> }];</p>
<p>##XML的代理方法    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">###pragma mark 1. 开始,准备工作，初始化一些数组，字符串</div><div class="line">- (void)parserDidStartDocument:(NSXMLParser *)parser</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;开始解析文档&quot;);</div><div class="line">    // 准备工作</div><div class="line">    // 1&gt; dataList</div><div class="line">        </div><div class="line">    // 2&gt; elementString</div><div class="line">    // 清空可变字符串不要设置成nil,使用setString只是清空内容,下次不会再次实例化</div><div class="line">&#125;</div><div class="line"></div><div class="line">###pragma mark 2. 所有开始一个节点:&lt;element&gt;，开始节点都在这里进行</div><div class="line">- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;开始节点:%@ %@&quot;, elementName, attributeDict);</div><div class="line">    // 如果是&lt;video&gt;新建对象</div><div class="line">    if ([elementName isEqualToString:@&quot;video&quot;]) &#123;</div><div class="line">        self.v = [[Video alloc] init];</div><div class="line">        self.v.videoId = attributeDict[@&quot;videoId&quot;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 每开始一个新节点之前都清空elementString</div><div class="line">    // 避免上一次的结果被重复拼接,例如拼完名字是&quot;abc&quot;,再拼长度就会变成&quot;vda1234&quot;</div><div class="line">    [self.elementString setString:@&quot;&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">###pragma mark 3. 查找内容,可能会重复多次</div><div class="line">- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string</div><div class="line">&#123;</div><div class="line">    // 拼接字符串</div><div class="line">    [self.elementString appendString:string];</div><div class="line">&#125;</div><div class="line"></div><div class="line">###pragma mark 4. 节点结束 &lt;/element&gt;</div><div class="line">- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;结束节点 %@&quot;, elementName);</div><div class="line">    // 判断如果是&lt;name&gt;要复制</div><div class="line">    if ([elementName isEqualToString:@&quot;video&quot;]) &#123;</div><div class="line">        [self.dataList addObject:self.v];</div><div class="line">    &#125; else if (![elementName isEqualToString:@&quot;videos&quot;]) &#123;</div><div class="line">        [self.v setValue:self.elementString forKey:elementName];</div><div class="line">    &#125;</div><div class="line">    // 提示:使用KVC只要是数值型的属性,kvc会自动设置成对应的属性,而无需程序员参与</div><div class="line">//    if ([elementName isEqualToString:@&quot;name&quot;]) &#123;</div><div class="line">//        self.v.name = self.elementString;</div><div class="line">//    &#125; else if ([elementName isEqualToString:@&quot;length&quot;]) &#123;</div><div class="line">//        self.v.length = [NSNumber numberWithInt:[self.elementString intValue]];</div><div class="line">//    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">###pragma mark 5. 文档结束</div><div class="line">- (void)parserDidEndDocument:(NSXMLParser *)parser</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;解析结束 %@ %@&quot;, self.dataList, [NSThread currentThread]);</div><div class="line">    </div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [self.tableView reloadData];</div><div class="line">        </div><div class="line">        // 关闭刷新控件的刷新</div><div class="line">        [self.refreshControl endRefreshing];</div><div class="line">    &#125;);</div><div class="line">//    [self.dataList enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">//        NSLog(@&quot;%@&quot;, obj);</div><div class="line">//    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">###pragma mark 6. 出错处理</div><div class="line">- (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parseError</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;%@&quot;, parseError.localizedDescription);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS-XML-JSON/">iOS XML JSON</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/09/21/xml笔记/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-hello-world" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/20/hello-world/">Hello World</a>
    </h1>
  

        <a href="/2014/09/20/hello-world/" class="archive-article-date">
  	<time datetime="2014-09-20T10:55:26.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2014-09-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hello-World/">Hello World</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2014/09/20/hello-world/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 xiao-xi
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js?v=4.0.0.js"></script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Block</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Foundation Kit</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">c</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">AFNetworking</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">KVC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Xcode调试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Git 操作</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">UINavigationController</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">SVN</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">oc</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">UIScorllView</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">UI_Notes</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">cocoaPods</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Hello World</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">accelerator-key</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Mac上搭建hexo极简指南</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">内存管理</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">kinds of viewControllers</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Data Persistence</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">background_task</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">VIM_Sed</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">standards</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">vim的使用</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">Local/Romote Notification</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">certificate</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">iOS XML JSON</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">小逗网络、iOS、Reactnative、Shell、Python</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>